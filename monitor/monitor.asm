.module 	monitor
.title 		Monitor

.include	'common.def'
.include	'io.def'

BANKR = 0xA0			;BANK REGISTER PORT BASE

MEM_X = 16
MEM_Y = 8

STACK	= 0x60FF

.area	BOOT	(ABS)

RST0:
	DI
	LXI	SP,STACK	;INITALIZE STACK
	JMP START
	
;*********************************************************
;* MAIN PROGRAM
;*********************************************************
.area 	_CODE

START:
	CALL	IO_INIT		;INITIALIZE IO
	
	MVI	A,8		;SET INTERRUPT MASK
	SIM
	EI			;ENABLE INTERRUPTS

	CALL	IO_BEEP		;MAKE SOME NOISE!
	
	CALL	INIT

	CALL	DISPLAY		;DISPLAY MEMORY CONTENTS

LOOP:
	CALL	WAITFORCHAR

; KEY WAS PRESSED
	CPI	'4
	JNZ	NOLEFT
; LEFT: GO BACK ONE LINE (BASE = BASE-MEM_X)	
	MVI	A,MEM_X
	JMP	DECBASE		;UPDATE BASE
NOLEFT:
	CPI	'6
	JNZ	NORIGHT
; RIGHT: GO FORWARD ONE LINE (BASE = BASE+MEM_X)
	MVI	A,MEM_X
	JMP	INCBASE		;UPDATE BASE
NORIGHT:
	CPI	'8
	JNZ	NOUP
; UP: GO BACK ONE PAGE (BASE = BASE-MEM_X*MEM_Y)	
	MVI	A,MEM_X*MEM_Y
	JMP	DECBASE		;UPDATE BASE
NOUP:
	CPI	'2
	JNZ	NODOWN
; DOWN: GO FORWARD ONE PAGE LINES (BASE = BASE+MEM_X*MEM_Y)
	MVI	A,MEM_X*MEM_Y
	JMP	INCBASE		;UPDATE BASE
NODOWN:
	CPI	'G
	JNZ	NOGOTO
; GOTO: ASK FOR ADDRESS AND GO TO IT
	CALL	IO_CLS		;CLEAR SCREEN
	LXI	H,GOTOSTR	;PRINT GOTO STRING
	CALL	IO_PUTS
	CALL 	GETHL		;GET ADDRESS IN H-L
	JNC	SKIP		;CY = 0 IF FAILED
	SHLD	BASE		;H-L IN WORD AT 'BASE'
	JMP	SKIP	
NOGOTO:
	CPI	'E
	JNZ	NOEXEC
	
; EXEC: ASK FOR ADDRESS AND RUN IT
	CALL	IO_CLS		;CLEAR SCREEN
	
	LXI	H,EXECSTR	;PRINT EXEC STRING
	CALL	IO_PUTS
	
	CALL 	GETHL		;GET ADDRESS IN H-L
	JNC	SKIP		;CY = 0 IF FAILED

	PCHL			;H&L TO PROGRAM COUNTER
	JMP	SKIP	

NOEXEC:
	CPI	'I
	JNZ	NOIN

; IN:	ASK WHICH PORT AND PRINT VALUE OF PORT

	CALL	IO_CLS		;CLEAR SCREEN
	
	LXI	H,INSTR		;PRINT INPUT STRING
	CALL	IO_PUTS
	
	CALL	GETBYTE		;GET PORT # IN A
	JNC	SKIP		;CY = 0 IF FAILED
	
	CALL	INPORTA		;GET VALUE OF INPUT PORT 'A' IN 'A'
	
	LXI	H,0x0001	;NEXT LINE
	CALL	IO_GOTOXY
	
	LXI	H,INSTR2	;PRINT INPUT STRING 2
	CALL	IO_PUTS
	
	CALL	IO_PUTCH	;PRINT VALUE IN 'A' (HEX)
	
	CALL	WAITFORCHAR	
	
	JMP	SKIP

NOIN:
	CPI	'O
	JNZ	NOOUT
	
; OUT:	ASK FOR PORT AND VALUE

	CALL	IO_CLS		;CLEAR SCREEN
	
	LXI	H,OUTSTR	;PRINT OUTPUT STRING
	CALL	IO_PUTS
	
	CALL	GETBYTE		;GET PORT # IN A
	JNC	SKIP		;CY = 0 IF FAILED
	
	MOV	B,A		;PUT PORT # IN B
	
	LXI	H,0x0001	;NEXT LINE
	CALL	IO_GOTOXY
	
	LXI	H,OUTSTR2	;PRINT INPUT STRING 2
	CALL	IO_PUTS

	CALL	GETBYTE		;GET VALUE IN A
	JNC	SKIP		;CY = 0 IF FAILED

	CALL	OUTPORTA	;SET VALUE OF OUTPUT PORT #'B' TO 'A'
	
	JMP	SKIP

NOOUT:
	CPI	'V
	JNZ	NOVERSION
	
; VERSION: PRINT VERSION NUMBER AND DATE
	CALL	IO_CLS		;CLEAR SCREEN
	
	LXI	H,VERSIONSTR	;PRINT VERSION STRING
	CALL	IO_PUTS

	CALL	WAITFORCHAR	
	
	JMP	SKIP	
	
NOVERSION:

	CPI	'B
	JNZ	NOBEEP
	
; BEEP: MAKES A SOUND
	CALL	IO_CLS		;CLEAR SCREEN
	
	LXI	H,BEEPSTR	;PRINT BEEP STRING
	CALL	IO_PUTS
	
	CALL	GETBYTE		;GET VALUE IN A
	JNC	SKIP		;CY = 0 IF FAILED
	
	CALL	IO_SOUNDON
	MVI	A,5		
	CALL 	IO_DELAY	;WAIT 5 * 100 MS
	CALL	IO_SOUNDOFF

	JMP 	SKIP
	
NOBEEP:	

	CPI	'D
	JNZ	NODELAY
	
; DELAY: TESTS DELAY - WAITS USER DEFINED AMOUNT OF TIME
	CALL	IO_CLS		;CLEAR SCREEN
	
	LXI	H,DELAYSTR	;PRINT DELAY STRING
	CALL	IO_PUTS
	
	CALL	GETBYTE		;GET VALUE IN A
	JNC	SKIP		;CY = 0 IF FAILED
	
	PUSH  PSW
	CALL	IO_BEEP
	POP 	PSW
	CALL	IO_DELAY
	CALL 	IO_BEEP

	JMP 	SKIP
	
NODELAY:

SKIP:		
	CALL 	DISPLAY
	
	JMP 	LOOP		;AD INFINITUM


INIT:
	PUSH	H
	
	MVI	H,0
	MVI	L,0
	SHLD	BASE		;BASE ADDRESS = 0
	
	POP	H
	RET
	
DISPLAY:
	PUSH 	PSW
	PUSH	B
	PUSH	D
	PUSH	H
	
	CALL	IO_CLS		;CLEAR SCREEN

	MVI	C,0		;Y LOOP (0..MEM_Y)

	LDA	BASE
	MOV	E,A
	LDA	BASE+1
	MOV	D,A
	
YLOOP:	
	MVI	B,0		;X = 0
	
	MVI	H,0		;GOTOXY: 0,Y
	MOV	L,C
	CALL	IO_GOTOXY

; PRINT ADDRESS
	MVI	A,#'(		;PRINT ADDRESS IN FORMAT
	CALL	IO_PUTC		;'(1234)'
	MOV	A,D
	CALL	IO_PUTCH
	MOV	A,E
	CALL	IO_PUTCH
	MVI	A,#')
	CALL	IO_PUTC

; GET MEMORY AT ADDRESS

XLOOP:
	MVI	A,#' 		;PRINT SPACE
	CALL	IO_PUTC

	LDAX	D		;GET BYTE AT D-E
	CALL	IO_PUTCH	;PRINT IN HEX

	INX	D		;INCREMENT ADDRESS

	INR	B		;X++
	MOV	A,B
	CPI	MEM_X
	JNZ	XLOOP		;X LOOP

	INR	C		;Y++
	MOV	A,C
	CPI	MEM_Y
	JNZ	YLOOP		;Y LOOP

	POP	H
	POP	D
	POP	B
	POP 	PSW

	RET


INCBASE:
	PUSH 	B
	PUSH	H
	
	LHLD	BASE		;WORD AT 'BASE' IN H-L
	
	MOV	C,A		;INCREMENT IN B-C
	MVI	B,0
	
	DAD	B		;ADD TO H-L
	
	SHLD	BASE		;H-L IN WORD AT 'BASE'
	
	POP	H
	POP	B
	JMP	SKIP		;RETURN IN LOOP

DECBASE:
	PUSH	PSW
	PUSH 	B
	PUSH	H
	
	LHLD	BASE		;WORD AT 'BASE' IN H-L
	
; NEGATIVE VALUE IN B-C (TWO'S COMPLEMENT)
	
	CMA			;COMPLEMENT A

	MOV	C,A		;COMPLEMENT VALUE IN B-C
	MVI	B,255
	
	INX	B		;ADD ONE TO B-C
	
	DAD	B		;ADD TO H-L (EFFECTIVELY SUBSTRACTING A)
	
	SHLD	BASE		;H-L IN WORD AT 'BASE'
	
	POP	H
	POP	B
	POP	PSW
	
	JMP	SKIP		;RETURN IN LOOP

; PORT IN A
INPORTA:
	PUSH	H
	
	LXI	H,INOUTF	;FUNCTION BASE ADDRESS
	MVI	M,0xDB		;(IN)
	
	INX	H
	
	MOV	M,A		;(PORT #)
	
	INX	H
	
	MVI	M,0xC9		;(RET)
	
	CALL	INOUTF		;CALL NEW FUNCTION
	
	POP	H
	
	RET

; PORT IN B, VALUE IN A
OUTPORTA:
	PUSH	H
	
	LXI	H,INOUTF	;FUNCTION BASE ADDRESS
	MVI	M,0xD3		;(OUT)
	
	INX	H
	
	MOV	M,B		;(PORT #)
	
	INX	H
	
	MVI	M,0xC9		;(RET)
	
	CALL	INOUTF		;CALL NEW FUNCTION
	
	POP	H
	
	RET

WAITFORCHAR:
1$:
	CALL	IO_GETCHAR	;CHECK TERMINAL
	ORA	A
	JZ	1$

	RET

;********************************************************
; GETHL:  GETS A 16 BIT VALUE IN H-L, CY=1 IF EVERYTHING OK
GETHL:
	CALL	GETBYTE		;GET FIRST BYTE
	RNC			;IF BAD, DON'T WAIT FOR SECOND
	MOV	H,A		;SAVE IN HIGH BYTE OF RESULT
	CALL	GETBYTE		;GET SECOND BYTE
	MOV	L,A		;SAVE IN LOW BYTE OF RESULT
	
	RET
	
;********************************************************
; GETBYTE: GETS A BYTE FOR ACC FROM KEYBOARD, CY=0 IF FAILS
GETBYTE:
	PUSH	B		;SAVE B-C PAIR
	CALL	GETNIB		;GET FIRST NIBBLE
	JNC	RETGB		;IF BAD, DON'T WAIT FOR MORE
	RLC			;SHIFT INTO.
	RLC			;UPPER NIBBLE.
	RLC			;OF RESULT.
	RLC			;SO WE CAN INSERT LOWER NIBBLE
	MOV	B,A		;KEEP HIGH DIGIT IN B
	CALL	GETNIB		;GET SECOND DIGIT
	JNC	RETGB		;IF BAD, INDICATE SO
	ORA	B		;INSERT HIGH DIGIT
	STC			;INDICATE SUCESS
RETGB:	POP	B		;RESTORE B-C PAIR
	RET
	
;********************************************************
; GETNIB: GETS A NIBBLE FROM THE KEYBOARD (IN ASCII HEX)
GETNIB:	CALL	WAITFORCHAR		;GET A CHARACTER
	CPI	#' 		;TEST FOR BLANK (ABORT1)
	RZ			;IF SO, RETURN INDICATING BAD (CY=0)
	CPI	0x0D		;TEST FOR <CR> (ABORT2)
	RZ			;IF SO, RETURN INDICATING BAD
	CPI	#'0		;TEST FOR INVALID (BELOW '0')
	JC	GETNIB		;IF SO, WAIT FOR MORE
	CPI	#'G		;TEST FOR INVALID (GREATER THAN 'F')
	JNC	GETNIB		;IF SO, IGNORE
	CALL	IO_PUTC		;DISPLAY CHARACTER
	CPI	0x3A		;TEST FOR INVALID
	JC	NUMH		;IF OK, WE ARE IN
	CPI	#'A		;TEST FOR INVALID
	JC	GETNIB		;IF BAD, IGNORE
	SUI	7		;CONVERT TO DIGIT
NUMH:	SUI	0x30		;CONVERT TO BINARY
	STC			;INDICATE SUCESS
	RET

;********************************************************
; General purpose functions
;********************************************************

;********************************************************
; SDELAY, WAITS A FINITE TIME INTERVAL (approx 2ms)
SDELAY:	PUSH	PSW
	PUSH	H		;SAVE H-L
	LXI	H,0x004C	;START COUNTING
DEL1:	DCX	H		;REDUCE COUNT
	MOV	A,H		;GET HIGH VALUE
	ORA	L		;TEST FOR ZERO WITH LOW VALUE
	JNZ	DEL1		;IF NOT, KEEP COUNTING
	POP	H		;RESTORE H-L
	POP	PSW
	RET
	
GOTOSTR:	.asciz	'Goto: '
EXECSTR:	.asciz	'Exec: '

INSTR:		.asciz	'Input - Port: '
INSTR2:		.asciz	'       Value: '

OUTSTR:		.asciz	'Output - Port: '
OUTSTR2:	.asciz	'        Value: '

BEEPSTR:	.asciz	'Beep - Note: '

DELAYSTR:	.asciz	'Delay - 100mS X: '

VERSIONSTR:	.asciz 'Monitor V1.0.0'

;*********************************************************
;* RAM VARIABLES
;*********************************************************

.area	_DATA	(REL,CON)

KBDTMP:		.ds	1
KBDFLG:		.ds	1

BASE:		.ds	2

INOUTF:		.ds	3

.area PAGE4 (REL,CON)
.area PAGE5 (REL,CON)
.area BANK0 (REL,CON)
.area BANK1 (REL,CON)

