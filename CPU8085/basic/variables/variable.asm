.module 	variable
.title 		Variable module

.include	'..\common\common.def'

.area	BOOT	(ABS)

.org	0x0038
RST7:	
	HLT

.area	_CODE

;*********************************************************
;* VAR_GET:  	GET VARIABLE (TAG IN BC)
;*		COPY IN VAR AT (H-L)
VAR_GET::
	XCHG					; SWAP HL<->DE
	
	CALL	VAR_INTERNALGET			; FIND VARIABLE
	
	MOV	A,H				; CHECK IF NOT FOUND
	ORA	A
	JNZ	SSKIP
	
	; NOT FOUND - CREATE NEW VARIABLE
	CALL	VAR_INTERNALNEW
	
SSKIP:	; HL CONTAINS ADDRESS OF VARIABLE
	XCHG					; SWAP HL<->DE

	INX	D				; GO TO BEGIN OF INT DATA
	INX	D

	PUSH	H				; SAVE INITIAL PARAM

	INX	H
	
	; COPY DATA
	LDAX	D				; BYTE 1
	MOV	M,A		
	INX	D
	INX	H
	
	LDAX	D				; BYTE 2
	MOV	M,A		
	INX	D
	INX	H

	LDAX	D				; BYTE 3
	MOV	M,A		
	INX	D
	INX	H

	LDAX	D				; BYTE 4
	MOV	M,A		
	INX	D
	INX	H
	
	POP	H				; GET BACK HL

	; IDENTIFY TYPE OF VARIABLE
	MOV	A,B				; TAG[0] IN ACC
	ORA	A				; UPDATE FLAGS
	JM	FLOAT				; CHECK IF INT/FLOAT

	; WE HAVE AN INTEGER
	MVI	M,SID_CINT			; SET AS INT
	RET

FLOAT:	; WE HAVE A STRING
	MVI	M,SID_CSTR			; SET AS STRING
	RET


VAR_SET::
	RET


;*********************************************************
;* VAR_INTERNALNEW:  	CREATES NEW VARIABLE, FROM TAG IN BC
;*			DOES NOT CHECK FOR EXISTANCE OF VARIABLE
;*			ADDRESS.  RETURNS ADDRESS OF NEW VAR
;*			IN HL
VAR_INTERNALNEW::
	LHLD	VAR_HIPTR			; GO TO TOP OF VAR AREA
	
	PUSH	H
	
	MOV	M,B				; WRITE TAG[0]
	INX	H				; HL++
	MOV	M,C				; WRITE TAG[1]
	INX	H				; HL++
	
	; FILL THE REST WITH ZEROS
	MVI	M,0				
	INX	H
	MVI	M,0
	INX	H
	MVI	M,0
	INX	H
	
	SHLD	VAR_HIPTR			; NEW TOP OF VAR AREA

	POP	H				; GET BACK ADDRESS OF NEW VAR
	RET


;*********************************************************
;* VAR_INTERNALGET:  	SEARCH FOR VARIABLE, SETS HL
;*			IF FOUND, ELSE 0x0000
;*			INPUT: TAG IN BC
VAR_INTERNALGET::
	PUSH	D
	
	LHLD	VAR_HIPTR			; TOP OF VAR PTR IN HL
	XCHG					; SWAP HL<->DE
	LHLD	VAR_LOPTR			; DE = BOTTOM OF VAR MEM

LOOP:	
	; CHECK IF WE GOT TO TOP OF VAR MEMORY
	MOV	A,E				; LO BYTE IN ACC
	CMP	L				; COMPARE WITH LO CURR POS
	JNZ	SKIP

	MOV	A,D				; HI BYTE IN ACC
	CMP	H				; COMPARE WITH HI CURR POS 
	JNZ	SKIP

	; EQUAL
	LXI	H,0				; RETURN 0
	POP	D
	RET
	
SKIP:
	MOV	A,B				; TAG[0] IN ACC
	CMP	M				; CHECK WITH CURR VAR
	INX	H				; HL++
	JNZ	PLUS4
	
	MOV	A,C				; TAG[1] IN ACC
	CMP	M				; CHECK WITH CURR VAR
	INX	H				; HL++
	JNZ	PLUS3				
	
	; FOUND IT
	DCX	H				; GO BACK TO BEGINNING
	DCX	H				; OF VAR 
	POP	D
	RET
	
PLUS4:	
	INX	H
PLUS3:
	INX	H
	INX	H
	INX	H
	JMP	LOOP


;*********************************************************
;* RAM VARIABLES
;*********************************************************

.area	DATA	(REL,CON)

VAR_TEMP1::		.ds	4		; TEMPORARY VARIABLE
VAR_TEMP2::		.ds	4		; TEMPORARY VARIABLE
VAR_TEMP3::		.ds	4		; TEMPORARY VARIABLE

VAR_LOPTR::		.ds	2		; BOTTOM OF VAR MEMORY
VAR_HIPTR::		.ds	2		; TOP OF VAR MEMORY
