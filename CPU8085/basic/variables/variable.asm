.module 	variable
.title 		Variable module

.include	'..\common\common.def'
.include	'..\error\error.def'
.include	'..\program\program.def'
.include	'..\integer\integer.def'
.include	'..\strings\strings.def'

.area	BOOT	(ABS)

.org	0x0038
RST7:	
	HLT

.area	_CODE

;*********************************************************
;* VAR_GET:  	GET VARIABLE (TAG IN BC)
;*		COPY IN VAR AT (H-L)
VAR_GET::
	PUSH	D
	XCHG					; SWAP HL<->DE
	
	CALL	VAR_INTERNALGET			; FIND VARIABLE
	
	MOV	A,H				; CHECK IF NOT FOUND
	ORA	A
	JNZ	1$
	
	; NOT FOUND - CREATE NEW VARIABLE
	CALL	VAR_INTERNALNEW
	
1$:	; HL CONTAINS ADDRESS OF VARIABLE
	XCHG					; SWAP HL<->DE

	INX	D				; GO TO BEGIN OF INT DATA
	INX	D

	PUSH	H				; SAVE INITIAL PARAM

	INX	H
	
	; COPY DATA
	LDAX	D				; BYTE 1
	MOV	M,A		
	INX	D
	INX	H
	
	LDAX	D				; BYTE 2
	MOV	M,A		
	INX	D
	INX	H

	LDAX	D				; BYTE 3
	MOV	M,A		
	INX	D
	INX	H

	LDAX	D				; BYTE 4
	MOV	M,A		
	
	POP	H				; GET BACK HL

	; IDENTIFY TYPE OF VARIABLE
	MOV	A,B				; TAG[0] IN ACC
	ORA	A				; UPDATE FLAGS
	JM	2$				; CHECK IF INT/FLOAT

	; WE HAVE AN INTEGER
	MVI	M,SID_CINT			; SET AS INT
	POP	D
	RET

2$:	; WE HAVE A STRING
	MVI	M,SID_CSTR			; SET AS STRING
	POP	D
	RET


;*********************************************************
;* VAR_SET:  	SET VARIABLE (TAG IN BC)
;*		WITH DATA AT (H-L)
VAR_SET::
	PUSH	D
	PUSH	H
	XCHG					; SWAP HL<->DE
	
	CALL	VAR_INTERNALGET			; FIND VARIABLE
	
	MOV	A,H				; CHECK IF NOT FOUND
	ORA	A
	JNZ	SSKIP
	
	; NOT FOUND - CREATE NEW VARIABLE
	CALL	VAR_INTERNALNEW
	
SSKIP:	; HL CONTAINS ADDRESS OF VARIABLE
	XCHG					; SWAP HL<->DE

	LDAX	D				; LOAD TAG[0] IN ACC
	ORA	A				; UPDATE FLAGS
	JP	SSKIP2				; CHECK HI BYTE (1=STR)
	
	; STRING VARIABLE
	MOV	A,M				; READ VARIABLE TYPE
	INX	H
	CPI	SID_CSTR			; MUST BE STRING
	JNZ	ERR_TYPEMISMATCH
	
	MOV	A,M				; SIZE OF STRING IN A
	STA	VAR_TEMPSIZE			; STORE IN TEMP VAR
	INX	H

	PUSH	B
	
	; LOAD STRING PTR IN BC
	MOV	C,M				; LO BYTE OF STRING PTR
	INX	H
	MOV	B,M				; HI BYTE OF STRING PTR
	
	MOV	A,C				; PUT STRING PTR IN INT_ACC0
	STA	INT_ACC0
	MOV	A,B
	STA	INT_ACC0+1
	
	; IF THE PTR TO THE STRING IF LOWER THAN THE PROGRAM MEMORY, IT MEANS
	; THAT THE STRING DATA IS IN A TEMPORARY BUFFER - HENCE, WE MUST 
	; COPY THE STRING
	
	LXI	H,PRG_LOPTR			; BOTTOM OF PRG MEMPTR IN HL
	CALL	INT_CMP				; COMPARE STRPTR AND PRGMEM

	CPI	-1				; CHECK FOR '<'
	JNZ	NOCOPY
	
	; WE HAVE TO COPY THE STRING
	MOV	A,B				; SWAP BC<->DE
	MOV	B,D
	MOV	D,A
	
	MOV	A,C
	MOV	C,E
	MOV	E,A

	LDA	VAR_TEMPSIZE			; READ BACK SIZE IN ACC
		
	CALL	STR_ALLOCATE			; ALLOCATE NEW STRING
						; ADDRESS IN HL
						
	PUSH	H				; KEEP ADDRESS
	PUSH	B				; KEEP VARIABLE PTR				

	MOV	B,A				; COPY SIZE TO B							
	CALL 	STR_COPY			; COPY THE STRING

	POP	D				; RESTORE VARIABLE PTR
	POP	B				; RESTORE ADDRESS IN BC
	
NOCOPY:
	; STRING PTR IS IN BC
	INX	D				; SKIP TAG
	INX	D

	LDA	VAR_TEMPSIZE			; READ BACK SIZE
	STAX	D				; STORE IT
	INX	D				; DEST++

	MOV	A,C				; LO BYTE OF ADDRESS
	STAX	D
	INX	D

	MOV	A,B				; HI BYTE OF ADDRESS
	STAX	D
	
	POP	B
	POP	H
	POP	D
	RET
	
SSKIP2:
	; INT VARIABLE
	INX	D				; GO TO BEGIN OF INT DATA
	INX	D

	MOV	A,M				; READ VARIABLE TYPE
	INX	H
	CPI	SID_CINT			; MUST BE INT
	JNZ	ERR_TYPEMISMATCH
	
	; COPY DATA
	MOV	A,M				; BYTE 1
	STAX	D
	INX	D
	INX	H
	
	MOV	A,M				; BYTE 2
	STAX	D

END:
	POP	H
	POP	D
	RET

;*********************************************************
;* VAR_INTERNALNEW:  	CREATES NEW VARIABLE, FROM TAG IN BC
;*			DOES NOT CHECK FOR EXISTANCE OF VARIABLE
;*			ADDRESS.  RETURNS ADDRESS OF NEW VAR
;*			IN HL
VAR_INTERNALNEW::
	LHLD	VAR_HIPTR			; GO TO TOP OF VAR AREA
	
	PUSH	H
	
	MOV	M,B				; WRITE TAG[0]
	INX	H				; HL++
	MOV	M,C				; WRITE TAG[1]
	INX	H				; HL++
	
	; FILL THE REST WITH ZEROS
	MVI	M,0				
	INX	H
	MVI	M,0
	INX	H
	MVI	M,0
	INX	H
	
	SHLD	VAR_HIPTR			; NEW TOP OF VAR AREA

	POP	H				; GET BACK ADDRESS OF NEW VAR
	RET


;*********************************************************
;* VAR_INTERNALGET:  	SEARCH FOR VARIABLE, SETS HL
;*			IF FOUND, ELSE 0x0000
;*			INPUT: TAG IN BC
VAR_INTERNALGET::
	PUSH	D
	
	LHLD	VAR_HIPTR			; TOP OF VAR PTR IN HL
	XCHG					; SWAP HL<->DE
	LHLD	VAR_LOPTR			; DE = BOTTOM OF VAR MEM

LOOP:	
	; CHECK IF WE GOT TO TOP OF VAR MEMORY
	MOV	A,E				; LO BYTE IN ACC
	CMP	L				; COMPARE WITH LO CURR POS
	JNZ	SKIP

	MOV	A,D				; HI BYTE IN ACC
	CMP	H				; COMPARE WITH HI CURR POS 
	JNZ	SKIP

	; EQUAL
	LXI	H,0				; RETURN 0
	POP	D
	RET
	
SKIP:
	MOV	A,B				; TAG[0] IN ACC
	CMP	M				; CHECK WITH CURR VAR
	INX	H				; HL++
	JNZ	PLUS4
	
	MOV	A,C				; TAG[1] IN ACC
	CMP	M				; CHECK WITH CURR VAR
	INX	H				; HL++
	JNZ	PLUS3				
	
	; FOUND IT
	DCX	H				; GO BACK TO BEGINNING
	DCX	H				; OF VAR 
	POP	D
	RET
	
PLUS4:	
	INX	H
PLUS3:
	INX	H
	INX	H
	INX	H
	JMP	LOOP


;*********************************************************
;* RAM VARIABLES
;*********************************************************

.area	DATA	(REL,CON)

VAR_TEMP1::		.ds	4		; TEMPORARY VARIABLE
VAR_TEMP2::		.ds	4		; TEMPORARY VARIABLE
VAR_TEMP3::		.ds	4		; TEMPORARY VARIABLE

VAR_LOPTR::		.ds	2		; BOTTOM OF VAR MEMORY
VAR_HIPTR::		.ds	2		; TOP OF VAR MEMORY

VAR_TEMPSIZE:		.ds	1		; USED BY SET
