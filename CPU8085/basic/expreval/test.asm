.module 	exprevaltest
.title 		Tests expreval Module

.include	'expreval.def'
.include	'..\integer\integer.def'
.include	'..\tokenize\tokenize.def'
.include	'..\strings\strings.def'
.include	'..\io\io.def'
.include	'..\error\error.def'

STACK	==	0xFFFF			;SYSTEM STACK

.area	BOOT	(ABS)

.org 	0x0000
	
RST0:
	DI
	LXI	SP,STACK		;INITALIZE STACK
	JMP 	START


;*********************************************************
;* MAIN PROGRAM
;*********************************************************
.area 	_CODE

START:

	MVI	A,8			;SET INTERRUPT MASK
	SIM
	EI				;ENABLE INTERRUPTS

	CALL	IO_INIT
	LXI	H,0
	SHLD	ERR_CURRLINE

	; SET STR PTRS
	LXI	H,0xA000
	SHLD	STR_LOPTR
	SHLD	STR_HIPTR

	CALL	INT_INIT
	CALL	EXP_INIT

;	JMP	TEST_BINCALC
;	JMP	TEST_BINREL
;	JMP	TEST_BINLOG
;	JMP	TEST_NEG
;	JMP	TEST_NOT
;	JMP	TEST_ABS
;	JMP	TEST_SGN
;	JMP	TEST_PEEK
;	JMP	TEST_RND
;	JMP	TEST_SQR
;	JMP	TEST_LEN
;	JMP	TEST_ASC
;	JMP	TEST_VAL
;	JMP	TEST_CHR
;	JMP	TEST_ADDSTR
;	JMP	TEST_BINRELSTR
;	JMP	TEST_STR
;	JMP	TEST_LEFT
;	JMP	TEST_RIGHT
;	JMP	TEST_MID
	JMP	TEST_ERROR
	
TEST_BINCALC:	; TEST OF ARITHMETIC OPERATORS
	LXI	H,TESTSTR0
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTR001	; 4+4
	CALL 	EVAL		; RESULT: 8
	LXI	H,TESTSTR002	; 4-4
	CALL 	EVAL		; RESULT: 0
	LXI	H,TESTSTR003	; 4*4
	CALL 	EVAL		; RESULT: 16
	LXI	H,TESTSTR004	; 4/4
	CALL 	EVAL		; RESULT: 1

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK

TEST_BINREL:	; TEST OF BINARY RELATIONS
	LXI	H,TESTSTR1
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTR101	; 4=4
	CALL 	EVAL		; RESULT: TRUE
	LXI	H,TESTSTR102	; 4<>4
	CALL 	EVAL		; RESULT: FALSE
	LXI	H,TESTSTR103	; 4<4
	CALL 	EVAL		; RESULT: FALSE
	LXI	H,TESTSTR104	; 4>4
	CALL 	EVAL		; RESULT: FALSE
	LXI	H,TESTSTR105	; 4<=4
	CALL 	EVAL		; RESULT: TRUE
	LXI	H,TESTSTR106	; 4>=4
	CALL 	EVAL		; RESULT: TRUE
	LXI	H,TESTSTR111	; 1=10
	CALL 	EVAL		; RESULT: FALSE
	LXI	H,TESTSTR112	; 1<>10
	CALL 	EVAL		; RESULT: TRUE
	LXI	H,TESTSTR113	; 1<10
	CALL 	EVAL		; RESULT: TRUE
	LXI	H,TESTSTR114	; 1>10
	CALL 	EVAL		; RESULT: FALSE
	LXI	H,TESTSTR115	; 1<=10
	CALL 	EVAL		; RESULT: TRUE
	LXI	H,TESTSTR116	; 1>=10
	CALL 	EVAL		; RESULT: FALSE
	LXI	H,TESTSTR121	; 10=1
	CALL 	EVAL		; RESULT: FALSE
	LXI	H,TESTSTR122	; 10<>1
	CALL 	EVAL		; RESULT: TRUE
	LXI	H,TESTSTR123	; 10<1
	CALL 	EVAL		; RESULT: FALSE
	LXI	H,TESTSTR124	; 10>1
	CALL 	EVAL		; RESULT: TRUE
	LXI	H,TESTSTR125	; 10<=1
	CALL 	EVAL		; RESULT: FALSE
	LXI	H,TESTSTR126	; 10>=1
	CALL 	EVAL		; RESULT: TRUE

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK


TEST_BINLOG:	; TESTS OF LOGICAL OPERATORS (AND OR XOR)
	LXI	H,TESTSTR2
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTR201	; 0 AND 0
	CALL 	EVAL		; RESULT: 0
	LXI	H,TESTSTR202	; 0 AND 255
	CALL 	EVAL		; RESULT: 0
	LXI	H,TESTSTR203	; 255 AND 0
	CALL 	EVAL		; RESULT: 0
	LXI	H,TESTSTR204	; 255 AND 255
	CALL 	EVAL		; RESULT: 255

	LXI	H,TESTSTR211	; 0 OR 0
	CALL 	EVAL		; RESULT: 0
	LXI	H,TESTSTR212	; 0 OR 255
	CALL 	EVAL		; RESULT: 255
	LXI	H,TESTSTR213	; 255 OR 0
	CALL 	EVAL		; RESULT: 255
	LXI	H,TESTSTR214	; 255 OR 255
	CALL 	EVAL		; RESULT: 255

	LXI	H,TESTSTR221	; 0 XOR 0
	CALL 	EVAL		; RESULT: 0
	LXI	H,TESTSTR222	; 0 XOR 255
	CALL 	EVAL		; RESULT: 255
	LXI	H,TESTSTR223	; 255 XOR 0
	CALL 	EVAL		; RESULT: 255
	LXI	H,TESTSTR224	; 255 XOR 255
	CALL 	EVAL		; RESULT: 0

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK

TEST_NEG:	;	TESTS OF NEGATION
	LXI	H,TESTSTR3
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTR301	; -10
	CALL 	EVAL		; RESULT: -10
	LXI	H,TESTSTR302	; --10
	CALL 	EVAL		; RESULT: +10
	LXI	H,TESTSTR303	; -(2+2)
	CALL 	EVAL		; RESULT: -4
	LXI	H,TESTSTR304	; -(-5--1)
	CALL 	EVAL		; RESULT: +4

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK

TEST_NOT:	;	TESTS OF NOT
	LXI	H,TESTSTR4
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTR401	; NOT 0
	CALL 	EVAL		; RESULT: -1
	LXI	H,TESTSTR402	; NOT NOT 0
	CALL 	EVAL		; RESULT: 0
	LXI	H,TESTSTR403	; NOT -1
	CALL 	EVAL		; RESULT: 0
	LXI	H,TESTSTR404	; NOT --1
	CALL 	EVAL		; RESULT: -2

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK

TEST_ABS:	;	TESTS OF ABS
	LXI	H,TESTSTR5
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTR501	; ABS ( 0  ) 
	CALL 	EVAL		; RESULT: 0
	LXI	H,TESTSTR502	; ABS ( 1  ) 
	CALL 	EVAL		; RESULT: 1
	LXI	H,TESTSTR503	; ABS ( -1 )
	CALL 	EVAL		; RESULT: 1
	LXI	H,TESTSTR504	; ABS ( - ABS ( -10 ) )
	CALL 	EVAL		; RESULT: 10

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK

TEST_SGN:	;	TESTS OF SGN
	LXI	H,TESTSTR6
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTR601	; SGN ( 0  )
	CALL 	EVAL		; RESULT:  0
	LXI	H,TESTSTR602	; SGN ( 1  )
	CALL 	EVAL		; RESULT: 1
	LXI	H,TESTSTR603	; SGN ( -1 )
	CALL 	EVAL		; RESULT: -1
	LXI	H,TESTSTR604	; SGN ( -32768 )
	CALL 	EVAL		; RESULT: -1
	LXI	H,TESTSTR605	; SGN ( 32767 )
	CALL 	EVAL		; RESULT: 1

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK

TEST_PEEK:	;	TESTS OF PEEK
	LXI	H,TESTSTR7
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTR701	; PEEK ( 0  )
	CALL 	EVAL		; 
	LXI	H,TESTSTR702	; PEEK ( 32767  )
	CALL 	EVAL		; 
	LXI	H,TESTSTR703	; PEEK ( -1 )
	CALL 	EVAL		; 

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK

TEST_RND:	;	TESTS OF RND
	LXI	H,TESTSTRR0
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTRRND	; RND(0)
	CALL 	EVAL		; 
	LXI	H,TESTSTRRND	; RND(0)
	CALL 	EVAL		; 
	LXI	H,TESTSTRRND	; RND(0)
	CALL 	EVAL		; 
	LXI	H,TESTSTRRND	; RND(0)
	CALL 	EVAL		; 

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK

TEST_SQR:	;	TESTS OF SQR
	LXI	H,TESTSTR8
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTR801	; SQR(10)
	CALL 	EVAL		; RESULT: 3
	LXI	H,TESTSTR802	; SQR(100)
	CALL 	EVAL		; RESULT: 10
	LXI	H,TESTSTR803	; SQR(1000)
	CALL 	EVAL		; RESULT: 31
	LXI	H,TESTSTR804	; SQR(10000)
	CALL 	EVAL		; RESULT: 100

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK

TEST_LEN:	;	TESTS OF LEN
	LXI	H,TESTSTR9
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTR901	; LEN("")
	CALL 	EVAL		; RESULT: 0
	LXI	H,TESTSTR902	; SQR("A")
	CALL 	EVAL		; RESULT: 1
	LXI	H,TESTSTR903	; SQR("12345")
	CALL 	EVAL		; RESULT: 5

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK

TEST_ASC:	;	TESTS OF ASC
	LXI	H,TESTSTRA
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTRA01	; ASC("1234")
	CALL 	EVAL		; RESULT: '1'
	LXI	H,TESTSTRA02	; ASC(" ")
	CALL 	EVAL		; RESULT: 32

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK

TEST_VAL:	;	TESTS OF VAL
	LXI	H,TESTSTRB
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTRB01	; VAL("1234")
	CALL 	EVAL		; RESULT: 1234
	LXI	H,TESTSTRB02	; VAL("-666")
	CALL 	EVAL		; RESULT: -666

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK

TEST_CHR:	;	TESTS OF CHR$
	LXI	H,TESTSTRC
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTRC01	; CHR$(65)
	CALL 	EVAL		; RESULT: "A"
	LXI	H,TESTSTRC02	; CHR$(48)
	CALL 	EVAL		; RESULT: "0"

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK

TEST_ADDSTR:	;	TESTS OF ADD (STR)
	LXI	H,TESTSTRD
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTRD01	; "1234"+"66"
	CALL 	EVAL		; RESULT: "123466"
	LXI	H,TESTSTRD02	; "6666"+""
	CALL 	EVAL		; RESULT: "6666"

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK

TEST_BINRELSTR:	;	TESTS OF BINARY RELATIONS
	LXI	H,TESTSTRE
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTRE01	; "A"="A"
	CALL 	EVAL		; RESULT: TRUE
	LXI	H,TESTSTRE02	; "B"<>"B"
	CALL 	EVAL		; RESULT: FALSE
	LXI	H,TESTSTRE03	; "C"<"C"
	CALL 	EVAL		; RESULT: FALSE
	LXI	H,TESTSTRE04	; "C">"C"
	CALL 	EVAL		; RESULT: FALSE
	LXI	H,TESTSTRE05	; "D"<="D"
	CALL 	EVAL		; RESULT: TRUE
	LXI	H,TESTSTRE06	; "E">="E"
	CALL 	EVAL		; RESULT: TRUE

	LXI	H,TESTSTRE11	; "A"="B"
	CALL 	EVAL		; RESULT: FALSE
	LXI	H,TESTSTRE12	; "A"<>"B"
	CALL 	EVAL		; RESULT: TRUE
	LXI	H,TESTSTRE13	; "A"<"B"
	CALL 	EVAL		; RESULT: TRUE
	LXI	H,TESTSTRE14	; "A">"B"
	CALL 	EVAL		; RESULT: FALSE
	LXI	H,TESTSTRE15	; "A"<="B"
	CALL 	EVAL		; RESULT: TRUE
	LXI	H,TESTSTRE16	; "A">="B"
	CALL 	EVAL		; RESULT: FALSE

	LXI	H,TESTSTRE21	; "B"="A"
	CALL 	EVAL		; RESULT: FALSE
	LXI	H,TESTSTRE22	; "B"<>"A"
	CALL 	EVAL		; RESULT: TRUE
	LXI	H,TESTSTRE23	; "B"<"A"
	CALL 	EVAL		; RESULT: FALSE
	LXI	H,TESTSTRE24	; "B">"A"
	CALL 	EVAL		; RESULT: TRUE
	LXI	H,TESTSTRE25	; "B"<="A"
	CALL 	EVAL		; RESULT: FALSE
	LXI	H,TESTSTRE26	; "B">="A"
	CALL 	EVAL		; RESULT: TRUE

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK

TEST_STR:	;	TESTS OF STR$
	LXI	H,TESTSTRF
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTRF01	; STR$(0)
	CALL 	EVAL		; RESULT: " 0"
	LXI	H,TESTSTRF02	; STR$(-1)
	CALL 	EVAL		; RESULT: "-1"
	LXI	H,TESTSTRF03	; STR$(1234)
	CALL 	EVAL		; RESULT: "1234"
	LXI	H,TESTSTRF04	; STR$(10+10)
	CALL 	EVAL		; RESULT: "20"
	LXI	H,TESTSTRF05	; STR$(10*10)
	CALL 	EVAL		; RESULT: "100"

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK

TEST_LEFT:	;	TESTS OF LEFT$
	LXI	H,TESTSTRG
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTRG01	; LEFT$("ABCD",2)
	CALL 	EVAL		; RESULT: "AB"
	LXI	H,TESTSTRG02	; LEFT$("ABCD",4)
	CALL 	EVAL		; RESULT: "ABCD"
	LXI	H,TESTSTRG03	; LEFT$("ABCD",66)
	CALL 	EVAL		; RESULT: "ABCD"
	LXI	H,TESTSTRG04	; LEFT$("",0)
	CALL 	EVAL		; RESULT: ""
	LXI	H,TESTSTRG05	; LEFT$("",5)
	CALL 	EVAL		; RESULT: ""

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK

TEST_RIGHT:	;	TESTS OF RIGHT$
	LXI	H,TESTSTRH
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTRH01	; RIGHT$("ABCD",2)
	CALL 	EVAL		; RESULT: "CD"
	LXI	H,TESTSTRH02	; RIGHT$("ABCD",4)
	CALL 	EVAL		; RESULT: "ABCD"
	LXI	H,TESTSTRH03	; RIGHT$("ABCD",66)
	CALL 	EVAL		; RESULT: "ABCD"
	LXI	H,TESTSTRH04	; RIGHT$("",0)
	CALL 	EVAL		; RESULT: ""
	LXI	H,TESTSTRH05	; RIGHT$("",5)
	CALL 	EVAL		; RESULT: ""

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK

TEST_MID:	;	TESTS OF MID$
	LXI	H,TESTSTRI
	CALL	IO_PUTS
	CALL	IO_PUTCR

	LXI	H,TESTSTRI01	; MID$("ABCD",66,66)
	CALL 	EVAL		; RESULT: ""
	LXI	H,TESTSTRI02	; MID$("ABCD",2,0)
	CALL 	EVAL		; RESULT: ""
	LXI	H,TESTSTRI03	; MID$("ABCD",1,1)
	CALL 	EVAL		; RESULT: "A"
	LXI	H,TESTSTRI04	; MID$("ABCD",2,2)
	CALL 	EVAL		; RESULT: "BC"
	LXI	H,TESTSTRI05	; MID$("ABCD",3,66)
	CALL 	EVAL		; RESULT: "CD"
	LXI	H,TESTSTRI06	; MID$("ABCD",4,1)
	CALL 	EVAL		; RESULT: "D"

	CALL	EXP_DUMPSTACK	; PRINT RESULTS
	CALL	EXP_CLEARSTACK

TEST_ERROR:	;	TESTS OF ERROR HANDLING
	LXI	H,TESTSTRX
	CALL	IO_PUTS
	CALL	IO_PUTCR
	
	LXI	H,X1
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX01	; 2 + "2"
	CALL 	EVAL		; RESULT: TYPE MISMATCH
X1:
	LXI	H,X2
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX02	; 2 AND "2"
	CALL 	EVAL		; RESULT: TYPE MISMATCH
X2:	
	LXI	H,X3
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX03	; "THIS" = 3
	CALL 	EVAL		; RESULT: TYPE MISMATCH
X3:
	LXI	H,X4
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX04	; "THIS" / "THAT"
	CALL 	EVAL		; RESULT: TYPE MISMATCH
X4:

	LXI	H,X5
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX05	; "THIS" AND "THAT"
	CALL 	EVAL		; RESULT: TYPE MISMATCH
X5:
	LXI	H,X6
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX06	; -"THIS"
	CALL 	EVAL		; RESULT: TYPE MISMATCH
X6:
	LXI	H,X7
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX07	; NOT "THIS"
	CALL 	EVAL		; RESULT: TYPE MISMATCH
X7:
	LXI	H,X8
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX08	; ABS("THIS")
	CALL 	EVAL		; RESULT: TYPE MISMATCH
X8:
	LXI	H,X9
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX09	; SGN("THIS")
	CALL 	EVAL		; RESULT: TYPE MISMATCH
X9:
	LXI	H,XA
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX0A	; PEEK("THIS")
	CALL 	EVAL		; RESULT: TYPE MISMATCH
XA:
	LXI	H,XB
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX0B	; RND("THIS")
	CALL 	EVAL		; RESULT: TYPE MISMATCH
XB:
	LXI	H,XC
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX0C	; SQR("THIS")
	CALL 	EVAL		; RESULT: TYPE MISMATCH
XC:
	LXI	H,XD
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX0D	; LEN(1234)
	CALL 	EVAL		; RESULT: TYPE MISMATCH
XD:
	LXI	H,XE
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX0E	; ASC(1234)
	CALL 	EVAL		; RESULT: TYPE MISMATCH
XE:
	LXI	H,XF
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX0F	; VAL(1234)
	CALL 	EVAL		; RESULT: TYPE MISMATCH
XF:
	LXI	H,XG
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX0G	; CHR$("THIS")
	CALL 	EVAL		; RESULT: TYPE MISMATCH
XG:
	LXI	H,XH
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX0H	; STR$("THIS")
	CALL 	EVAL		; RESULT: TYPE MISMATCH
XH:
	LXI	H,XI
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX0I	; LEFT$("THIS", "THAT")
	CALL 	EVAL		; RESULT: TYPE MISMATCH
XI:
	LXI	H,XJ
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX0J	; LEFT$(3, 4)
	CALL 	EVAL		; RESULT: TYPE MISMATCH
XJ:
	LXI	H,XK
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX0K	; RIGHT$("THIS", "THAT")
	CALL 	EVAL		; RESULT: TYPE MISMATCH
XK:
	LXI	H,XL
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX0L	; RIGHT$(3, 4)
	CALL 	EVAL		; RESULT: TYPE MISMATCH
XL:
	LXI	H,XM
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX0M	; MID$(3, 2, 1)
	CALL 	EVAL		; RESULT: TYPE MISMATCH
XM:
	LXI	H,XN
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX0N	; MID$("A", "B", 1)
	CALL 	EVAL		; RESULT: TYPE MISMATCH
XN:
	LXI	H,XO
	SHLD	ERR_RESTARTPTR
	LXI	H,TESTSTRX0O	; MID$("A", 3, "C")
	CALL 	EVAL		; RESULT: TYPE MISMATCH
XO:
LOOP:
	JMP	LOOP

	
EVAL:	
	PUSH	H
	CALL	TOK_TOKENIZE1
	POP	H
	XCHG
	LXI	H,OUTSTR
	CALL	TOK_TOKENIZE2
	LXI	H,OUTSTR
	CALL	EXP_EXPREVAL
	RET	



.area	DATA	(REL,CON)


TESTSTR0:	.asciz	'TESTS OF BINARY ARITHMETIC OPERATIONS'
TESTSTR001:	.asciz	'4+4'			; 8
TESTSTR002:	.asciz	'4-4'			; 0
TESTSTR003:	.asciz	'4*4'			; 16
TESTSTR004:	.asciz	'4/4'			; 1


TESTSTR1:	.asciz	'TESTS OF BINARY RELATIONS'
TESTSTR101:	.asciz	'4=4'			; TRUE
TESTSTR102:	.asciz	'4<>4'			; FALSE
TESTSTR103:	.asciz	'4<4'			; FALSE
TESTSTR104:	.asciz	'4>4'			; FALSE
TESTSTR105:	.asciz	'4<=4'			; TRUE
TESTSTR106:	.asciz	'4>=4'			; TRUE

TESTSTR111:	.asciz	'1=10'			; FALSE
TESTSTR112:	.asciz	'1<>10'			; TRUE
TESTSTR113:	.asciz	'1<10'			; TRUE
TESTSTR114:	.asciz	'1>10'			; FALSE
TESTSTR115:	.asciz	'1<=10'			; TRUE
TESTSTR116:	.asciz	'1>=10'			; FALSE

TESTSTR121:	.asciz	'10=1'			; FALSE
TESTSTR122:	.asciz	'10<>1'			; TRUE
TESTSTR123:	.asciz	'10<1'			; FALSE
TESTSTR124:	.asciz	'10>1'			; TRUE
TESTSTR125:	.asciz	'10<=1'			; FALSE
TESTSTR126:	.asciz	'10>=1'			; TRUE

TESTSTR2:	.asciz	'TESTS OF LOGICAL OPERATORS (AND OR XOR)'
TESTSTR201:	.asciz	'0 AND 0'		; 0
TESTSTR202:	.asciz	'0 AND 255'		; 0
TESTSTR203:	.asciz	'255 AND 0'		; 0
TESTSTR204:	.asciz	'255 AND 255'		; 255

TESTSTR211:	.asciz	'0 OR 0'		; 0
TESTSTR212:	.asciz	'0 OR 255'		; 255
TESTSTR213:	.asciz	'255 OR 0'		; 255
TESTSTR214:	.asciz	'255 OR 255'		; 255

TESTSTR221:	.asciz	'0 XOR 0'		; 0
TESTSTR222:	.asciz	'0 XOR 255'		; 255
TESTSTR223:	.asciz	'255 XOR 0'		; 255
TESTSTR224:	.asciz	'255 XOR 255'		; 0

TESTSTR3:	.asciz	'TESTS OF NEGATION'
TESTSTR301:	.asciz	'-10'			; -10
TESTSTR302:	.asciz	'--10'			; +10
TESTSTR303:	.asciz	'-(2+2)'		; -4
TESTSTR304:	.asciz	'-(-5--1)'		; +4

TESTSTR4:	.asciz	'TESTS OF NOT'
TESTSTR401:	.asciz	'NOT 0'			; -1
TESTSTR402:	.asciz	'NOT NOT 0'		; 0
TESTSTR403:	.asciz	'NOT -1'		; 0
TESTSTR404:	.asciz	'NOT --1'		; -2

TESTSTR5:	.asciz	'TESTS OF ABS'
TESTSTR501:	.asciz	'ABS ( 0  ) '		; 0
TESTSTR502:	.asciz	'ABS ( 1  ) '		; 1
TESTSTR503:	.asciz	'ABS ( -1 )'		; 1
TESTSTR504:	.asciz	'ABS ( - ABS ( -10 ) )'	; 10

TESTSTR6:	.asciz	'TESTS OF SGN'
TESTSTR601:	.asciz	'SGN ( 0  ) '		; 0
TESTSTR602:	.asciz	'SGN ( 1  ) '		; 1
TESTSTR603:	.asciz	'SGN ( -1 )'		; -1
TESTSTR604:	.asciz	'SGN ( -32768 )'	; -1
TESTSTR605:	.asciz	'SGN ( 32767 )'		; 1

TESTSTR7:	.asciz	'TESTS OF PEEK'
TESTSTR701:	.asciz	'PEEK ( 0  ) '		; 
TESTSTR702:	.asciz	'PEEK ( 32767  ) '	; 
TESTSTR703:	.asciz	'PEEK ( -1 )'		; 1

TESTSTRR0:	.asciz	'TESTS OF RND'
TESTSTRRND:	.asciz	'RND(0)'		; 

TESTSTR8:	.asciz	'TESTS OF SQR'
TESTSTR801:	.asciz	'SQR(10)'		; 3
TESTSTR802:	.asciz	'SQR(100)'		; 10
TESTSTR803:	.asciz	'SQR(1000)'		; 31
TESTSTR804:	.asciz	'SQR(10000)'		; 100

TESTSTR9:	.asciz	'TESTS OF LEN'
TESTSTR901:	.asciz	'LEN("")'		; 0
TESTSTR902:	.asciz	'LEN("A")'		; 1
TESTSTR903:	.asciz	'LEN("12345")'		; 5

TESTSTRA:	.asciz	'TESTS OF ASC'
TESTSTRA01:	.asciz	'ASC("1234")'		; '1'
TESTSTRA02:	.asciz	'ASC(" ")'		; 32

TESTSTRB:	.asciz	'TESTS OF VAL'
TESTSTRB01:	.asciz	'VAL("1234")'		; 1234
TESTSTRB02:	.asciz	'VAL("-666")'		; -666

TESTSTRC:	.asciz	'TESTS OF CHR$'
TESTSTRC01:	.asciz	'CHR$(65)'		; "A"
TESTSTRC02:	.asciz	'CHR$(48)'		; "0"

TESTSTRD:	.asciz	'TESTS OF ADD (STR)'
TESTSTRD01:	.asciz	'"1234"+"66"'		; "123466"
TESTSTRD02:	.asciz	'"6666"+""'		; "6666"

TESTSTRE:	.asciz	'TESTS OF BINARY RELATIONS'
TESTSTRE01:	.asciz	'"A"="A"'		; TRUE
TESTSTRE02:	.asciz	'"B"<>"B"'		; FALSE
TESTSTRE03:	.asciz	'"C"<"C"'		; FALSE
TESTSTRE04:	.asciz	'"C">"C"'		; FALSE
TESTSTRE05:	.asciz	'"D"<="D"'		; TRUE
TESTSTRE06:	.asciz	'"E">="E"'		; TRUE

TESTSTRE11:	.asciz	'"A"="B"'		; FALSE
TESTSTRE12:	.asciz	'"A"<>"B"'		; TRUE
TESTSTRE13:	.asciz	'"A"<"B"'		; TRUE
TESTSTRE14:	.asciz	'"A">"B"'		; FALSE
TESTSTRE15:	.asciz	'"A"<="B"'		; TRUE
TESTSTRE16:	.asciz	'"A">="B"'		; FALSE

TESTSTRE21:	.asciz	'"B"="A"'		; FALSE
TESTSTRE22:	.asciz	'"B"<>"A"'		; TRUE
TESTSTRE23:	.asciz	'"B"<"A"'		; FALSE
TESTSTRE24:	.asciz	'"B">"A"'		; TRUE
TESTSTRE25:	.asciz	'"B"<="A"'		; FALSE
TESTSTRE26:	.asciz	'"B">="A"'		; TRUE

TESTSTRF:	.asciz	'TESTS OF STR$'
TESTSTRF01:	.asciz	'STR$(0)'		; " 0"
TESTSTRF02:	.asciz	'STR$(-1)'		; "-1"
TESTSTRF03:	.asciz	'STR$(1234)'		; "1234"
TESTSTRF04:	.asciz	'STR$(10+10)'		; "20"
TESTSTRF05:	.asciz	'STR$(10*10)'		; "100"

TESTSTRG:	.asciz	'TESTS OF LEFT$'
TESTSTRG01:	.asciz	'LEFT$("ABCD",2)'	; "AB"
TESTSTRG02:	.asciz	'LEFT$("ABCD",4)'	; "ABCD"
TESTSTRG03:	.asciz	'LEFT$("ABCD",66)'	; "ABCD"
TESTSTRG04:	.asciz	'LEFT$("",0)'		; ""
TESTSTRG05:	.asciz	'LEFT$("",5)'		; ""

TESTSTRH:	.asciz	'TESTS OF RIGHT$'
TESTSTRH01:	.asciz	'RIGHT$("ABCD",2)'	; "CD"
TESTSTRH02:	.asciz	'RIGHT$("ABCD",4)'	; "ABCD"
TESTSTRH03:	.asciz	'RIGHT$("ABCD",66)'	; "ABCD"
TESTSTRH04:	.asciz	'RIGHT$("",0)'		; ""
TESTSTRH05:	.asciz	'RIGHT$("",5)'		; ""

TESTSTRI:	.asciz	'TESTS OF MID$'
TESTSTRI01:	.asciz	'MID$("ABCD",66,66)'	; ""
TESTSTRI02:	.asciz	'MID$("ABCD",2,0)'	; ""
TESTSTRI03:	.asciz	'MID$("ABCD",1,1)'	; "A"
TESTSTRI04:	.asciz	'MID$("ABCD",2,2)'	; "BC"
TESTSTRI05:	.asciz	'MID$("ABCD",3,66)'	; "CD"
TESTSTRI06:	.asciz	'MID$("ABCD",4,1)'	; "D"

TESTSTRX:	.asciz	'TESTS OF ERROR HANDLING'
TESTSTRX01:	.asciz	'2 + "2"'		; TYPE MISMATCH
TESTSTRX02:	.asciz	'2 AND "2"'		; TYPE MISMATCH
TESTSTRX03:	.asciz	'"THIS" = 3'		; TYPE MISMATCH
TESTSTRX04:	.asciz	'"THIS" / "THAT"'	; TYPE MISMATCH
TESTSTRX05:	.asciz	'"THIS" AND "THAT"'	; TYPE MISMATCH
TESTSTRX06:	.asciz	'-"THIS"'		; TYPE MISMATCH

TESTSTRX07:	.asciz	'NOT "THIS"'		; TYPE MISMATCH
TESTSTRX08:	.asciz	'ABS("THIS")'		; TYPE MISMATCH
TESTSTRX09:	.asciz	'SGN("THIS")'		; TYPE MISMATCH
TESTSTRX0A:	.asciz	'PEEK("THIS")'		; TYPE MISMATCH
TESTSTRX0B:	.asciz	'RND("THIS")'		; TYPE MISMATCH
TESTSTRX0C:	.asciz	'SQR("THIS")'		; TYPE MISMATCH
TESTSTRX0D:	.asciz	'LEN(1234)'		; TYPE MISMATCH
TESTSTRX0E:	.asciz	'ASC(1234)'		; TYPE MISMATCH
TESTSTRX0F:	.asciz	'VAL(1234)'		; TYPE MISMATCH
TESTSTRX0G:	.asciz	'CHR$("THIS")'		; TYPE MISMATCH
TESTSTRX0H:	.asciz	'STR$("THIS")'		; TYPE MISMATCH
TESTSTRX0I:	.asciz	'LEFT$("THIS", "THAT")'	; TYPE MISMATCH
TESTSTRX0J:	.asciz	'LEFT$(3, 4)'		; TYPE MISMATCH
TESTSTRX0K:	.asciz	'RIGHT$("THIS", "THAT")'; TYPE MISMATCH
TESTSTRX0L:	.asciz	'RIGHT$(3, 4)'		; TYPE MISMATCH
TESTSTRX0M:	.asciz	'MID$(3, 2, 1)'		; TYPE MISMATCH
TESTSTRX0N:	.asciz	'MID$("A", "B", 1)'	; TYPE MISMATCH
TESTSTRX0O:	.asciz	'MID$("A", 3, "C")'	; TYPE MISMATCH



OUTSTR:		.ds 128

