.module 	program
.title 		Program module

.include	'..\common\common.def'
.include	'..\error\error.def'
.include	'..\variables\variable.def'
.include	'..\integer\integer.def'
.include	'..\io\io.def'
.include	'..\tokenize\tokenize.def'

.area	_CODE

;*********************************************************
;* PRG_INIT:	INITIALIZES PROGRAM MODULE
PRG_INIT::
	MVI	A,FALSE
	LXI	H,0				; CLEAR PTRS

	SHLD	PRG_NEWLINEPTR
	SHLD	PRG_CURRLINEPTR
	SHLD	PRG_CURRPOSPTR
	SHLD	PRG_NEXTRETURNPOINTPTR
	SHLD	PRG_NEXTCURRLINEPTR
	SHLD	PRG_CURRLINE	
		
	STA	PRG_ISEND
	STA	PRG_ISNEXT
	STA	PRG_INIF

	RET

;*********************************************************
;* PRG_NEW:	CLEARS PROGRAM, VARIABLES
PRG_NEW::
	PUSH	H

	LHLD	PRG_LOPTR
	SHLD	PRG_HIPTR

	SHLD	VAR_LOPTR			; CLEAR VARIABLES
	SHLD	VAR_HIPTR
	
	CALL	PRG_INIT			; RESET FLAGS
	
	POP	H
	RET

;*********************************************************
;* PRG_LIST:	LISTS PROGRAM
PRG_LIST::
	PUSH	B
	PUSH	D
	PUSH	H
	
	LHLD	PRG_LOPTR			; BEGIN OF PROGRAM
	
1$:
	; CHECK IF END OF PROGRAM
	LDA	PRG_HIPTR			; CHECK LO BYTE
	CMP	L
	JNZ	2$
	
	LDA	PRG_HIPTR+1			; CHECK HI BYTE
	CMP	H
	JNZ	2$

	POP	H
	POP	D
	POP	B
	RET
	
2$:
	INX	H				; SKIP LENGTH OF LINE
	
	MOV	E,M				; LO BYTE OF LINE NO IN E
	INX	H
	MOV	D,M				; HI BYTE OF LINE NO IN D
	INX	H
	
	XCHG					; SWAP DE<->HL
	SHLD	INT_ACC0			; PUT IN INT_ACC0
	
	CALL	INT_ITOA			; CONVERT TO STRING
	CALL	IO_PUTS				; PRINT IT
	
	MVI	A,' 				; PUT SPACE
	CALL	IO_PUTC				; PRINT IT
	
	XCHG					; SWAP DE<->HL
	
	CALL	TOK_UNTOKENIZE			; PRINT LINE CONTENTS

	CALL	IO_PUTCR			; NEW LINE
	
	JMP	1$				; LOOP

;*********************************************************
;* PRG_FIND:	FINDS LINE SPECIFIED IN BC
;*		RETURNS PTR IN HL
;*		IF FOUND, CF = 1
;*		IF NOT, CF = 0 AND HL IS INSERTION POINT
PRG_FIND::
	PUSH	D

	LHLD	PRG_LOPTR			; HL->FIRST PROGRAM LINE

1$:	; CHECK IF END OF PROGRAM
	LDA	PRG_HIPTR			; CHECK LO BYTE
	CMP	L
	JNZ	2$
	
	LDA	PRG_HIPTR+1			; CHECK HI BYTE
	CMP	H
	JNZ	2$

	; 	END OF PROGRAM -> NOT FOUND
	ORA	A				; CLEAR CARRY FLAG
	POP	D
	RET

2$:
	INX	H
	MOV	E,M				; LOAD CURRENT LINE IN DE
	INX	H
	MOV	D,M
	DCX	H				; GO BACK TO BEGINNING
	DCX	H
	
	; 	BC -> LINE SEARCHED FOR
	; 	DE -> CURRENT LINE
	
	MOV	A,D				; COMPARE HI BYTE
	CMP	B
	JB	5$
	JZ	3$
	
	;	CURRENT LINE > LINE SEARCHED FOR
	ORA	A				; RESET CARRY FLAG
	POP	D
	RET
	
3$:	; 	HI BYTES ARE EQUAL, SO CHECK LO BYTES
	MOV	A,E				; COMPARE LO BYTE
	CMP	C
	JB	5$
	JZ	4$
	
	; 	CURRENT LINE > LINE SEARCHED FOR
	ORA	A				; RESET CARRY FLAG
	POP	D
	RET	
	
4$:	; 	CURRENT LINE == LINE SEARCHED FOR
	STC					; SET CARRY
	POP	D
	RET	
	
5$:	; 	NOT THIS ONE, GO TO NEXT LINE
	MOV	E,M				; LOAD SIZE IN E
	MVI	D,0				; DE = SIZE
	
	DAD	D				; HL = NEXT LINE
	
	JMP	1$				; LOOP

;*********************************************************
;* PRG_INSERT:	INSERTS LINE IN CURRENT PROGRAM
;*		IN: LINE NO TO INSERT IN BC
;*		IN: PTR TO LINE IN HL
;*		IN: LENGTH OF LINE IN E
;*		(REPLACE IF ALREADY EXISTS)
PRG_INSERT::
	PUSH	PSW				; PUSH LENGTH
	PUSH	H				; PUSH PTR TO NEW LINE
	PUSH	B				; PUSH LINE NUMBER

	ADI	3				; LENGTH = LENGTH + 3
	PUSH	PSW				; KEEP LENGTH
	
	CALL	PRG_FIND			; FIND LINE
	JNC	1$
	
	; LINE EXISTS - REMOVE IT
	CALL	PRG_REMOVEPTR
	
1$: 	

	POP	PSW
	PUSH	PSW
	STA	INT_ACC0			; STORE L+3 IN INT_ACC0
	MVI	A,0
	STA	INT_ACC0+1


	; ADDRESS TO INSERT AT IS IN HL
	SHLD	INT_ACC1			; PUT ADDR IN INT_ACC1
	
	LXI	H,INT_ACC1
	CALL	INT_ADD				; INT_ACC0 = ADDR+LENGTH+3
	
	LHLD	INT_ACC0			; READ BACK RESULT IN HL
	XCHG					; SWAP WITH DE
	
	LHLD	PRG_HIPTR			; TOP OF PROGRAM MEMORY IN HL
	SHLD	INT_ACC0
	
	LXI	H,INT_ACC1
	CALL	INT_SUB				; INT_ACC0 = HIPTR - ADDR
	
	LDA	INT_ACC0			; READ LO BYTE IN ACC
	MOV	C,A				; COPY TO C
	LDA	INT_ACC0+1			; READ HI BYTE IN ACC
	MOV	B,A				; COPY TO B
	
	LHLD	INT_ACC1			; READ ADDRESS IN HL
	XCHG					; SWAP HL<->DE
	
	CALL	C_MEMCPYF			; MOVE PROGRAM UP TO MAKE
						; SPACE FOR NEW LINE

	XCHG					; ADDRESS IN HL
						
	POP	PSW				; GET BACK LENGTH+3
	MOV	M,A				; PUT AT ADDR
	INX	H				; HL++
	
	POP	B				; GET BACK LINE NUMBER
	
	MOV	M,C				; LO BYTE
	INX	H
	MOV	M,B				; HI BYTE
	INX	H
	
	POP	D				; RESTORE NEW LINE PTR
	POP	PSW				; RESTORE LENGTH
	
	MOV	C,A				; COPY TO BC
	MVI	B,0
	CALL	C_MEMCPY			; COPY LINE CONTENTS
	
	MOV	A,C				; GET LENGTH
	ADI	3				; ADD 3
	MOV	C,A				; PUT BACK IN C
	
	LHLD	PRG_HIPTR			; GET HI PTR
	DAD	B				; ADD LENGTH+3
	SHLD	PRG_HIPTR			; BACK IN VAR
	SHLD	VAR_LOPTR
	SHLD	VAR_HIPTR
	
	RET

;*********************************************************
;* PRG_REMOVE:	REMOVES LINE FROM PROGRAM
;*		IN: LINE NO TO REMOVE IN BC
PRG_REMOVE::
	CALL	PRG_FIND			; FIND LINE
	JNC	1$
	
	; LINE EXISTS - REMOVE IT
	CALL	PRG_REMOVEPTR
	
1$: 	
	RET

;*********************************************************
;* PRG_REMOVE:	REMOVES LINE FROM PROGRAM
;*		IN: PTR OF LINE TO REMOVE IN HL
PRG_REMOVEPTR:
	PUSH	B
	PUSH	D
	PUSH	H
	
	SHLD	INT_ACC2			; STORE ADDR IN INT_ACC2

	MOV	C,M				; SIZE OF LINE IN BC
	MVI	B,0
	
	PUSH	B				; KEEP SIZE FOR LATER

	DAD	B				; HL = ADDR + SIZE
	
	SHLD	INT_ACC1			; STORE ADDR+SIZE IN INT_ACC1
	
	LHLD	PRG_HIPTR			; HI PTR IN HL
	SHLD	INT_ACC0			; STORE IN INT_ACC0
	
	LXI	H,INT_ACC1
	CALL	INT_SUB				; INT_ACC0 = HIPTR - (ADDR+SIZE)

	LHLD	INT_ACC0			; READ BACK RESULT
	MOV	B,H				; COPY IN BC (LENGTH)
	MOV	C,L		
	
	LHLD	INT_ACC1			; ADDR+SIZE IN HL
	XCHG					; HL<->DE
	
	LHLD	INT_ACC2			; ADDR IN HL
	
	CALL	C_MEMCPY

	LHLD	PRG_HIPTR			; HI PTR IN HL
	SHLD	INT_ACC0			; STORE IN INT_ACC0
	
	POP	H				; RESTORE SIZE
	SHLD	INT_ACC1			; STORE IN INT_ACC0
	
	LXI	H,INT_ACC1
	CALL	INT_SUB				; INT_ACC0 -= SIZE
	
	LHLD	INT_ACC0			; READ BACK RESULT
	SHLD	PRG_HIPTR			; NEW HI PTR
	SHLD	VAR_LOPTR
	SHLD	VAR_HIPTR

	POP	H
	POP	D
	POP	B
			
	RET

;*********************************************************
;* PRG_RUN:	RUNS CURRENT PROGRAM
PRG_RUN::
	LHLD	PRG_HIPTR			; CLEAR VARIABLES
	SHLD	VAR_LOPTR
	SHLD	VAR_HIPTR

	XCHG	
	LHLD	PRG_LOPTR			; LO PTR IN HL
	
	; CHECK IF LOPTR == HIPTR
	MOV	A,L
	CMP	E
	JNZ	1$
	
	MOV	A,H
	CMP	D
	JNZ	1$
	
	; HIPTR == LOPTR -> NO PROGRAM
	RET	

1$:	
	LXI	H,0
	SHLD	PRG_CURRPOSPTR			; SET CURRPOSPTR = 0
	SHLD	PRG_NEWLINEPTR			; SET NEWLINEPTR = 0

	LHLD	PRG_LOPTR
	SHLD	PRG_CURRLINEPTR			; CURR LINE = BEGIN OF PRG
	
	MVI	A,FALSE
	STA	PRG_ISEND
	STA	PRG_INIF	

	CALL	PRG_DOIT

	RET

;*********************************************************
;* PRG_GOTO:	GO TO SPECIFIED LINE
PRG_GOTO::
	RET

;*********************************************************
;* PRG_GOSUB:	GO TO SPECIFIED LINE, PUSH CURRENT ADDRESS
;*		ON THE STACK FOR RETURN
PRG_GOSUB::
	RET

;*********************************************************
;* PRG_RETURN:	POPS RETURN ADDRESS FROM THE STACK, 
;*		CONTINUE EXECUTION
PRG_RETURN::
	RET


;*********************************************************
;* PRG_END:	ENDS CURRENT PROGRAM
PRG_END::
	MVI	A,255
	STA	PRG_ISEND
	RET

;*********************************************************
;* PRG_STOP:	STOPS CURRENT PROGRAM, SAVES POSITION
;*		TO CONTINUE LATER
PRG_STOP::
	RET

;*********************************************************
;* PRG_CONTINUE:	CONTINUE RUNNING PROGRAM
PRG_CONTINUE::
	RET

;*********************************************************
;* PRG_FOR:	FOR LOOP
PRG_FOR::
	RET

;*********************************************************
;* PRG_NEXT:	END OF FOR LOOP
PRG_NEXT::
	RET

;*********************************************************
;* PRG_DOIT:	ACTUALLY RUNS THE PROGRAM
PRG_DOIT:
0$:
	LDA	PRG_ISEND			; CHECK IF END OF PRG
	CPI	FALSE
	JNZ	100$
	
	; EXIT IF CURRLINE < HI PROGRAM
	LHLD	PRG_CURRLINEPTR		
	XCHG
	LHLD	PRG_HIPTR

	; HI BYTE
	MOV	A,D				; CHECK HI BYTE
	CMP	H
	JB	1$
	JNZ	100$
	
	; (HI BYTE) CURRLINE IS = HI PROGRAM
	
	; LO BYTE
	MOV	A,E				; CHECK LO BYTE
	CMP	L
	JB	1$
	
	JMP	100$	
	
1$:	; CURRLINE IS < HI PROGRAM

	; CHECK IF CURRPOS != 0
	LHLD	PRG_CURRPOSPTR			; CURRPOS IN HL
	MVI	A,0
	ORA	H				; CHECK FOR ZERO
	ORA	L	
	JZ	2$

;;;

	JMP	3$
			
2$:	; CHECK IF CURRLINE != 0
	LHLD	PRG_CURRLINE			; CURRLINE IN HL
	MVI	A,0
	ORA	H
	ORA	L				; CHECK FOR ZERO
	JZ	3$

;;;

	; DECIDE WHICH LINE IS NEXT	
	
3$:	; CHECK IF CURRPOS != 0
	LHLD	PRG_CURRPOSPTR			; CURRPOS IN HL
	MVI	A,0
	ORA	H
	ORA	L				; CHECK FOR ZERO
	JZ	4$
	
	LHLD	PRG_NEWLINEPTR			; CURRLINE = NEWLINE
	SHLD	PRG_CURRLINEPTR
	
	LXI	H,0
	SHLD	PRG_NEWLINEPTR			; NEWLINE = 0

	JMP	0$				; LOOP
		
4$:	; CHECK IF NEWLINE != 0
	LHLD	PRG_NEWLINEPTR			; NEWLINE IN HL
	MVI	A,0
	ORA	H
	ORA	L				; CHECK FOR ZERO
	JZ	5$

	LHLD	PRG_NEWLINEPTR			; CURRLINE = NEWLINE
	SHLD	PRG_CURRLINEPTR
	
	LXI	H,0
	SHLD	PRG_NEWLINEPTR			; NEWLINE = 0
	SHLD	PRG_CURRPOSPTR			; CURRPOS = 0
	
	MVI	A,FALSE
	STA	PRG_INIF			; INIF = FALSE

	JMP	0$				; LOOP

5$:	; CHECK IF CURRLINE != 0
	LHLD	PRG_CURRLINE			; CURRLINE IN HL
	MVI	A,0
	ORA	H
	ORA	L				; CHECK FOR ZERO
	JZ	100$
	
;;;;;;;	

	JMP	0$				; LOOP
	

100$:
	MVI	A,FALSE				; RESET SOME FLAGS
	STA	PRG_ISEND
	STA	PRG_INIF
	
	LXI	H,0
	SHLD	PRG_CURRPOSPTR
	
	RET


;*********************************************************
;* RAM VARIABLES
;*********************************************************

.area	DATA	(REL,CON)

PRG_LOPTR::		.ds	2		; BOTTOM OF PROGRAM MEMORY
PRG_HIPTR::		.ds	2		; TOP OF PROGRAM MEMORY


PRG_CURRLINE:		.ds	2		; CURRENT LINE NUMBER

PRG_NEWLINEPTR:		.ds	2		; 
PRG_CURRLINEPTR:	.ds	2		; 
PRG_CURRPOSPTR:		.ds	2		; 
PRG_NEXTRETURNPOINTPTR:	.ds	2		; 
PRG_NEXTCURRLINEPTR:	.ds	2		; 

PRG_INIF:		.ds	1		; 
PRG_ISEND:		.ds	1		; 
PRG_ISNEXT:		.ds	1		; 
