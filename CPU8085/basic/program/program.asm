.module 	program
.title 		Program module

.include	'..\common\common.def'
.include	'..\error\error.def'
.include	'..\variables\variable.def'
.include	'..\integer\integer.def'
.include	'..\io\io.def'
.include	'..\tokenize\tokenize.def'
.include	'..\expreval\expreval.def'
.include	'..\strings\strings.def'

.area	_CODE

;*********************************************************
;* PRG_INIT:	INITIALIZES PROGRAM MODULE
PRG_INIT::
	PUSH	H

	MVI	A,FALSE
	LXI	H,0				; CLEAR PTRS

	MVI	A,FALSE
	LXI	H,0				; CLEAR PTRS

	SHLD	PRG_NEWLINEPTR
	SHLD	PRG_CURRLINEPTR
	SHLD	PRG_CURRPOSPTR
	SHLD	PRG_CURRLINE	

	STA	PRG_ISEND
	STA	PRG_INIF
	STA	PRG_ISNEXT

	; CREATE LINE ZERO (IMMEDIATE MODE)
	LHLD	PRG_LOPTR			; HL = BOTTOM OF PRG MEMORY
	INR	H				; HL = HL + 256
	
	SHLD	PRG_HIPTR			; NEW TOP OF PRG MEMORY
	SHLD	VAR_LOPTR
	SHLD	VAR_HIPTR

	LHLD	PRG_LOPTR
	MVI	M,0				; LENGTH = 0
	INX	H
	MVI	M,0				; LINE ZERO
	INX	H
	MVI	M,0

	INX	H				; 'NULL TERMINATES'
	MVI	M,0

	POP	H
	RET

;*********************************************************
;* PRG_RESET:	RESETS STATE VARIABLES
PRG_RESET::
	MVI	A,FALSE
	LXI	H,0				; CLEAR PTRS

	SHLD	PRG_NEWLINEPTR
	SHLD	PRG_CURRLINEPTR
	SHLD	PRG_CURRPOSPTR
	SHLD	PRG_CURRLINE	

	STA	PRG_ISEND
	STA	PRG_INIF
	STA	PRG_ISNEXT

	RET

;*********************************************************
;* PRG_CLR:	CLEARS VARIABLES, STRINGS
PRG_CLR::
	PUSH	H

	LHLD	PRG_HIPTR			; CLEAR VARIABLES
	SHLD	VAR_LOPTR
	SHLD	VAR_HIPTR

	LHLD	STR_HIPTR			; CLEAR STRING MEMORY
	SHLD	STR_LOPTR
	
	POP	H
	RET

;*********************************************************
;* PRG_NEW:	CLEARS PROGRAM, VARIABLES
PRG_NEW::
	PUSH	H

	LHLD	PRG_LOPTR
	INR	H				; SKIP LINE ZERO
	SHLD	PRG_HIPTR

	CALL	PRG_CLR				; CLEAR VARIABLES, STRINGS
	
	CALL	PRG_INIT			; RESET FLAGS
	
	POP	H
	RET

;*********************************************************
;* PRG_LIST:	LISTS PROGRAM
PRG_LIST::
	PUSH	B
	PUSH	D
	PUSH	H
	
	LHLD	PRG_LOPTR			; BEGIN OF PROGRAM
	INR	H				; SKIP LINE ZERO
	
1$:
	; CHECK IF END OF PROGRAM
	LDA	PRG_HIPTR			; CHECK LO BYTE
	CMP	L
	JNZ	2$
	
	LDA	PRG_HIPTR+1			; CHECK HI BYTE
	CMP	H
	JNZ	2$

	POP	H
	POP	D
	POP	B
	RET
	
2$:
	INX	H				; SKIP LENGTH OF LINE
	
	MOV	E,M				; LO BYTE OF LINE NO IN E
	INX	H
	MOV	D,M				; HI BYTE OF LINE NO IN D
	INX	H
	
	XCHG					; SWAP DE<->HL
	SHLD	INT_ACC0			; PUT IN INT_ACC0
	
	CALL	INT_ITOA			; CONVERT TO STRING
	CALL	IO_PUTS				; PRINT IT
	
	MVI	A,' 				; PUT SPACE
	CALL	IO_PUTC				; PRINT IT
	
	XCHG					; SWAP DE<->HL
	
	CALL	TOK_UNTOKENIZE			; PRINT LINE CONTENTS

	CALL	IO_PUTCR			; NEW LINE
	
	JMP	1$				; LOOP

;*********************************************************
;* PRG_FIND:	FINDS LINE SPECIFIED IN BC
;*		RETURNS PTR IN HL
;*		IF FOUND, CF = 1
;*		IF NOT, CF = 0 AND HL IS INSERTION POINT
PRG_FIND::
	PUSH	D

	; CHECK FOR LINE ZERO
	MOV	A,B
	ORA	C
	JZ	ERR_ILLEGAL

	LHLD	PRG_LOPTR			; HL->FIRST PROGRAM LINE
	INR	H				; SKIP LINE ZERO

1$:	; CHECK IF END OF PROGRAM
	LDA	PRG_HIPTR			; CHECK LO BYTE
	CMP	L
	JNZ	2$
	
	LDA	PRG_HIPTR+1			; CHECK HI BYTE
	CMP	H
	JNZ	2$

	; 	END OF PROGRAM -> NOT FOUND
	ORA	A				; CLEAR CARRY FLAG
	POP	D
	RET

2$:
	INX	H
	MOV	E,M				; LOAD CURRENT LINE IN DE
	INX	H
	MOV	D,M
	DCX	H				; GO BACK TO BEGINNING
	DCX	H
	
	; 	BC -> LINE SEARCHED FOR
	; 	DE -> CURRENT LINE
	
	MOV	A,D				; COMPARE HI BYTE
	CMP	B
	JB	5$
	JZ	3$
	
	;	CURRENT LINE > LINE SEARCHED FOR
	ORA	A				; RESET CARRY FLAG
	POP	D
	RET
	
3$:	; 	HI BYTES ARE EQUAL, SO CHECK LO BYTES
	MOV	A,E				; COMPARE LO BYTE
	CMP	C
	JB	5$
	JZ	4$
	
	; 	CURRENT LINE > LINE SEARCHED FOR
	ORA	A				; RESET CARRY FLAG
	POP	D
	RET	
	
4$:	; 	CURRENT LINE == LINE SEARCHED FOR
	STC					; SET CARRY
	POP	D
	RET	
	
5$:	; 	NOT THIS ONE, GO TO NEXT LINE
	MOV	E,M				; LOAD SIZE IN E
	MVI	D,0				; DE = SIZE
	
	DAD	D				; HL = NEXT LINE
	
	JMP	1$				; LOOP

;*********************************************************
;* PRG_INSERT:	INSERTS LINE IN CURRENT PROGRAM
;*		IN: LINE NO TO INSERT IN BC
;*		IN: PTR TO LINE IN HL
;*		IN: LENGTH OF LINE IN ACC
;*		(REPLACE IF ALREADY EXISTS)
PRG_INSERT::
	PUSH	PSW				; PUSH LENGTH
	PUSH	H				; PUSH PTR TO NEW LINE
	PUSH	B				; PUSH LINE NUMBER

	ADI	3				; LENGTH = LENGTH + 3
	PUSH	PSW				; KEEP LENGTH
	
	CALL	PRG_FIND			; FIND LINE
	JNC	1$
	
	; LINE EXISTS - REMOVE IT
	CALL	PRG_REMOVEPTR
	
1$: 	
	POP	PSW
	PUSH	PSW
	STA	INT_ACC0			; STORE L+3 IN INT_ACC0
	MVI	A,0
	STA	INT_ACC0+1

	; ADDRESS TO INSERT AT IS IN HL
	SHLD	INT_ACC1			; PUT ADDR IN INT_ACC1
	
	LXI	H,INT_ACC1
	CALL	INT_ADD				; INT_ACC0 = ADDR+LENGTH+3
	
	LHLD	INT_ACC0			; READ BACK RESULT IN HL
	XCHG					; SWAP WITH DE
	
	LHLD	PRG_HIPTR			; TOP OF PROGRAM MEMORY IN HL
	SHLD	INT_ACC0
	
	LXI	H,INT_ACC1
	CALL	INT_SUB				; INT_ACC0 = HIPTR - ADDR
	
	LDA	INT_ACC0			; READ LO BYTE IN ACC
	MOV	C,A				; COPY TO C
	LDA	INT_ACC0+1			; READ HI BYTE IN ACC
	MOV	B,A				; COPY TO B
	
	LHLD	INT_ACC1			; READ ADDRESS IN HL
	XCHG					; SWAP HL<->DE
	
	CALL	C_MEMCPYF			; MOVE PROGRAM UP TO MAKE
						; SPACE FOR NEW LINE

	XCHG					; ADDRESS IN HL
						
	POP	PSW				; GET BACK LENGTH+3
	MOV	M,A				; PUT AT ADDR
	INX	H				; HL++
	
	POP	B				; GET BACK LINE NUMBER
	
	MOV	M,C				; LO BYTE
	INX	H
	MOV	M,B				; HI BYTE
	INX	H
	
	POP	D				; RESTORE NEW LINE PTR
	POP	PSW				; RESTORE LENGTH
	
	MOV	C,A				; COPY TO BC
	MVI	B,0
	CALL	C_MEMCPY			; COPY LINE CONTENTS
	
	MOV	A,C				; GET LENGTH
	ADI	3				; ADD 3
	MOV	C,A				; PUT BACK IN C
	
	LHLD	PRG_HIPTR			; GET HI PTR
	DAD	B				; ADD LENGTH+3
	SHLD	PRG_HIPTR			; BACK IN VAR
	
	CALL	PRG_CLR				; CLEAR VARIABLES, STRINGS
	
	RET

;*********************************************************
;* PRG_REMOVE:	REMOVES LINE FROM PROGRAM
;*		IN: LINE NO TO REMOVE IN BC
PRG_REMOVE::
	CALL	PRG_FIND			; FIND LINE
	JNC	ERR_LINENOTFOUND
	
	; LINE EXISTS - REMOVE IT
	CALL	PRG_REMOVEPTR
	
	RET	

;*********************************************************
;* PRG_REMOVE:	REMOVES LINE FROM PROGRAM
;*		IN: PTR OF LINE TO REMOVE IN HL
PRG_REMOVEPTR:
	PUSH	B
	PUSH	D
	PUSH	H
	
	SHLD	INT_ACC2			; STORE ADDR IN INT_ACC2

	MOV	C,M				; SIZE OF LINE IN BC
	MVI	B,0
	
	PUSH	B				; KEEP SIZE FOR LATER

	DAD	B				; HL = ADDR + SIZE
	
	SHLD	INT_ACC1			; STORE ADDR+SIZE IN INT_ACC1
	
	LHLD	PRG_HIPTR			; HI PTR IN HL
	SHLD	INT_ACC0			; STORE IN INT_ACC0
	
	LXI	H,INT_ACC1
	CALL	INT_SUB				; INT_ACC0 = HIPTR - (ADDR+SIZE)

	LHLD	INT_ACC0			; READ BACK RESULT
	MOV	B,H				; COPY IN BC (LENGTH)
	MOV	C,L		
	
	LHLD	INT_ACC1			; ADDR+SIZE IN HL
	XCHG					; HL<->DE
	
	LHLD	INT_ACC2			; ADDR IN HL
	
	CALL	C_MEMCPY

	LHLD	PRG_HIPTR			; HI PTR IN HL
	SHLD	INT_ACC0			; STORE IN INT_ACC0
	
	POP	H				; RESTORE SIZE
	SHLD	INT_ACC1			; STORE IN INT_ACC0
	
	LXI	H,INT_ACC1
	CALL	INT_SUB				; INT_ACC0 -= SIZE
	
	LHLD	INT_ACC0			; READ BACK RESULT
	SHLD	PRG_HIPTR			; NEW HI PTR
	
	CALL	PRG_CLR				; CLEAR VARIABLES, STRINGS
	
	POP	H
	POP	D
	POP	B
			
	RET

;*********************************************************
;* PRG_RUN:	RUNS CURRENT PROGRAM
PRG_RUN::
	CALL	PRG_CLR				; CLEAR VARIABLES, STRINGS

	LHLD	PRG_HIPTR		
	XCHG	
	LHLD	PRG_LOPTR			; LO PTR IN HL
	INR	H				; SKIP LINE ZERO
	
	; CHECK IF LOPTR == HIPTR
	MOV	A,L
	CMP	E
	JNZ	1$
	
	MOV	A,H
	CMP	D
	JNZ	1$
	
	; HIPTR == LOPTR -> NO PROGRAM
	RET	

1$:	
	LHLD	PRG_LOPTR
	INR	H
	SHLD	PRG_NEWLINEPTR
	
	RET

;*********************************************************
;* PRG_RUNIMMEDIATE:	RUNS IMMEDIATE MODE
PRG_RUNIMMEDIATE::
	LXI	H,0
	SHLD	PRG_CURRPOSPTR			; SET CURRPOSPTR = 0
	SHLD	PRG_NEWLINEPTR			; SET NEWLINEPTR = 0

	LHLD	PRG_LOPTR
	SHLD	PRG_CURRLINEPTR			; CURR LINE = LINE ZERO
	
	MVI	A,FALSE
	STA	PRG_ISEND
	STA	PRG_INIF	

	CALL	PRG_DOIT

	RET

;*********************************************************
;* PRG_GOTO:	GO TO SPECIFIED LINE
;*		IN: BC = LINE NUMBER
PRG_GOTO::
	CALL	PRG_FIND			; SEARCH FOR THE LINE
	SHLD	PRG_NEWLINEPTR			; STORE AS NEW LINE
	JNC	ERR_LINENOTFOUND		; LINE NOT FOUND
	RET

;*********************************************************
;* PRG_GOSUB:	GO TO SPECIFIED LINE, PUSH CURRENT ADDRESS
;*		ON THE STACK FOR RETURN
;*		IN: BC = LINE NUMBER
;*		IN: HL = RETURN POINT
;*		IN: D  = INIF (TRUE/FALSE)
PRG_GOSUB::
	PUSH	B
	PUSH	D
	PUSH	H

	; GATHER DATA TO SAVE ON THE STACK
	MVI	A,SID_GOSUB			; FLAG AS GOSUB
	STA	EXP_STACKTEMP

	MOV	A,D				; SAVE INIF FLAG
	STA	EXP_STACKTEMP+4

	PUSH	H				; STORE RETURN PT
	
	CALL	PRG_FIND			; SEARCH FOR THE LINE
	SHLD	PRG_NEWLINEPTR			; STORE AS NEW LINE
	JNC	ERR_LINENOTFOUND		; LINE NOT FOUND
	
	LHLD	PRG_CURRLINEPTR			; GET CURRENT LINE IN HL
	
	
	; STORE IN TEMP VAR - AT THE SAME TIME, NEGATE THE ADDRESS FOR LATER
	MOV	A,L
	STA	EXP_STACKTEMP+1			; STORE IN TEMP VAR
	
	CMA	
	MOV	L,A				; L = ~LO BYTE
	
	MOV	A,H
	STA	EXP_STACKTEMP+2
	
	CMA
	MOV	H,A				; H = ~HI BYTE
	
	INX	H				; HL = -CURRLINE
	
	POP	D				; GET BACK RETURN PT IN DE
	
	DAD	D				; HL = RETURN PT - CURRLINE
	
	; MAKE SURE RESULT < 256
	MOV	A,H
	ORA	A
	JNZ	ERR_UNKNOWN
	
	MOV	A,L
	STA	EXP_STACKTEMP+3			; STORE IN TEMP VAR
	
	LXI	H,EXP_STACKTEMP
	CALL	EXP_PUSH			; PUSH ON THE STACK

	STC					; SET CARRY

	POP	H
	POP	D
	POP	B
	RET


;*********************************************************
;* PRG_RETURN:	POPS RETURN ADDRESS FROM THE STACK, 
;*		CONTINUE EXECUTION
PRG_RETURN::
	PUSH	B
	PUSH	D
	PUSH	H
	
	CALL	EXP_ISSTACKEMPTY		; CHECK IF EXP STACK IS EMPTY
	JC	ERR_RETURNWITHOUTGOSUB

	CALL	EXP_POP				; HL POINTS TO DATA
	
	MOV	A,M				; READ ID
	CPI	SID_GOSUB			; MUST BE GOSUB
	JNZ	ERR_RETURNWITHOUTGOSUB
	
	INX	H
	
	MOV	E,M				; READ LINEPTR
	INX	H
	MOV	D,M
	INX	H
	
	MOV	A,E
	STA	PRG_NEWLINEPTR			; SAVE AS NEW LINE
	MOV	A,D
	STA	PRG_NEWLINEPTR+1
	
	MOV	C,M				; READ LINE OFFSET IN BC
	MVI	B,0
	
	XCHG
	DAD	B				; PTR = PTR + OFFSET
	XCHG
	
	MOV	A,E
	STA	PRG_CURRPOSPTR			; SAVE AS NEW CURRPOS
	MOV	A,D
	STA	PRG_CURRPOSPTR+1
	
	INX	H
	MOV	A,M				; READ INIF
	STA	PRG_INIF			; SAVE IT
	
	POP	H
	POP	D
	POP	B
	RET


;*********************************************************
;* PRG_END:	ENDS CURRENT PROGRAM
PRG_END::
	MVI	A,TRUE
	STA	PRG_ISEND
	RET

;*********************************************************
;* PRG_FOR:	FOR LOOP
;*		IN: BC = VARIABLE ID
;*		IN: HL = RETURN POINT
;*		IN: D  = INIF (TRUE/FALSE)
PRG_FOR::

	PUSH	D				; PUSH INIF
	PUSH	H				; PUSH RETURN POINT
	
	LHLD	PRG_CURRLINEPTR			; READ CURRENT LINE
	PUSH	H				; PUSH ORIGINAL CURRENT LINE
	
	
LOOP:
	; SET VARIABLES
	
	POP	H				; GET BACK ORIG CURRENT LINE
	SHLD	PRG_CURRLINEPTR			; SET AS CURRENT LINE
	
	POP	H				; GET BACK RETURN POINT
	SHLD	PRG_CURRPOSPTR			; SET AS CURRPOS
	
	POP	D				; GET BACK INIF
	MOV	A,D
	STA	PRG_INIF			; STORE INIF FLAG
	
	MVI	A,FALSE
	STA	PRG_ISNEXT
	
	
	; PUSH BACK VALUES ON STACK
	PUSH	D				; PUSH INIF
	PUSH	H				; PUSH RETURN POINT
	
	LHLD	PRG_CURRLINEPTR			; READ CURRENT LINE
	PUSH	H				; PUSH ORIGINAL CURRENT LINE

	PUSH	B
	CALL	PRG_DOIT			; EXECUTE BLOCK
	POP	B
	
	LDA	PRG_ISNEXT			; CHECK ISNEXT VARIABLE
	CPI	FALSE
	JZ	END
	
	PUSH	H
	
	; NEXT - INCREMENT VARIABLE
	LXI	H,VAR_TEMP1
	CALL	VAR_GET				; GET VARIABLE

	LHLD	VAR_TEMP1+1			; GET INT VALUE
	SHLD	INT_ACC0			; PUT IN INT_ACC0
	
	CALL	EXP_POPPUSH			; GET PTR TO DATA SAVED ON
						; STACK - POINTER IN HL

	MOV	A,M				; READ STACK ID
	CPI	SID_FOR				; MUST BE FOR
	JNZ	ERR_UNKNOWN
	INX	H
				
	; PUT DATA IN INT_ACC1 AND INT_ACC2
	MOV	A,M
	STA	INT_ACC1			; END VALUE IN INT_ACC1
	INX	H
	
	MOV	A,M
	STA	INT_ACC1+1
	INX	H
	
	MOV	A,M
	STA	INT_ACC2			; STEP VALUE IN INT_ACC2
	INX	H
	
	MOV	A,M
	STA	INT_ACC2+1		
	
	LXI	H,INT_ACC2			; ADD STEP TO CURR VALUE
	
	MVI	A,0
	STA	INT_OVERFLOW			; RESET OVERFLOW FLAG

	CALL	INT_ADD
	
	LDA	INT_OVERFLOW
	ORA	A
	JNZ	ERR_OVERFLOW
	
	LHLD	INT_ACC0			; READ BACK RESULT
	SHLD	VAR_TEMP1+1			; PUT IN VAR_TEMP1	
		
	LXI	H,VAR_TEMP1			; SET NEW VALUE
	CALL	VAR_SET
	
	; CHECK EXIT CONDITION
	LXI	H,INT_ACC1
	CALL	INT_CMP				; EXIT IF CURR > END

	POP	H

	CPI	0x01
	JNZ	LOOP

	; END LOOP
	MVI	A,FALSE
	STA	PRG_ISNEXT
	
END:
	PUSH	H
	CALL	EXP_POP			; REMOVE DATA FROM STACK
	POP	H
	
	; GET STACK BACK TO NORMAL
	POP	D
	POP	D
	POP	D

	RET

;*********************************************************
;* PRG_NEXT:	END OF FOR LOOP
PRG_NEXT::
	PUSH	H
	CALL	EXP_ISSTACKEMPTY
	JC	ERR_NEXTWITHOUTFOR

	CALL	EXP_POPPUSH
	MOV	A,M
	CPI	SID_FOR
	JNZ	ERR_NEXTWITHOUTFOR

	MVI	A,TRUE
	STA	PRG_ISNEXT
	
	POP	H
	RET

;*********************************************************
;* PRG_DOIT:	ACTUALLY RUNS THE PROGRAM
PRG_DOIT::
0$:
	LDA	PRG_ISEND			; CHECK IF END OF PRG
	CPI	FALSE
	JNZ	100$
	
	; EXIT IF CURRLINE = HI PROGRAM
	LHLD	PRG_CURRLINEPTR		
	XCHG
	LHLD	PRG_HIPTR

	; HI BYTE
	MOV	A,D				; CHECK HI BYTE
	CMP	H
	JB	1$
	JNZ	100$
	
	; (HI BYTE) CURRLINE IS = HI PROGRAM
	
	; LO BYTE
	MOV	A,E				; CHECK LO BYTE
	CMP	L
	JB	1$
	
	JMP	100$	
	
1$:	; CURRLINE IS < HI PROGRAM

	; CHECK IF CURRPOS != 0
	LHLD	PRG_CURRPOSPTR			; CURRPOS IN HL
	MVI	A,0
	ORA	H				; CHECK FOR ZERO
	ORA	L	
	JZ	2$

	LHLD	PRG_CURRPOSPTR			; CURRPOS IN HL
	
	MVI	A,0
	STA	PRG_CURRPOSPTR			; CURRPOS = 0
	STA	PRG_CURRPOSPTR+1
	
	MVI	C,TRUE				; EVALUATE = TRUE
	LDA	PRG_INIF
	MOV	B,A				; INIF = PRG_INIF
	
	CALL	EXP_EXPREVAL			; EVALUATE CURRENT POS
	
	LDA	PRG_ISNEXT			; CHECK IF ISNEXT = TRUE
	CPI	TRUE
	JZ	100$

	JMP	3$
			
2$:	; CHECK IF CURRLINE != 0
	LHLD	PRG_CURRLINEPTR			; CURRLINE IN HL
	MVI	A,0
	ORA	H
	ORA	L				; CHECK FOR ZERO
	JZ	3$

	LHLD	PRG_CURRLINEPTR			; CURRLINE IN HL
	INX	H				; SKIP SIZE
	
	MOV	A,M				; LO BYTE OF LINE NUMBER
	INX	H
	STA	PRG_CURRLINE

	MOV	A,M				; HI BYTE OF LINE NUMBER
	INX	H
	STA	PRG_CURRLINE+1
	
	MVI	C,TRUE				; EVALUATE = TRUE
	LDA	PRG_INIF
	MOV	B,A				; INIF = PRG_INIF
	
	CALL	EXP_EXPREVAL			; EVALUATE CURRENT POS
	
	LDA	PRG_ISNEXT			; CHECK IF ISNEXT = TRUE
	CPI	TRUE
	JZ	100$

	; DECIDE WHICH LINE IS NEXT	
	
3$:	; CHECK IF CURRPOS != 0
	LHLD	PRG_CURRPOSPTR			; CURRPOS IN HL
	MVI	A,0
	ORA	H
	ORA	L				; CHECK FOR ZERO
	JZ	4$
	
	LHLD	PRG_NEWLINEPTR			; CURRLINE = NEWLINE
	SHLD	PRG_CURRLINEPTR
	
	LXI	H,0
	SHLD	PRG_NEWLINEPTR			; NEWLINE = 0

	JMP	0$				; LOOP
		
4$:	; CHECK IF NEWLINE != 0
	LHLD	PRG_NEWLINEPTR			; NEWLINE IN HL
	MVI	A,0
	ORA	H
	ORA	L				; CHECK FOR ZERO
	JZ	5$

	LHLD	PRG_NEWLINEPTR			; CURRLINE = NEWLINE
	SHLD	PRG_CURRLINEPTR
	
	LXI	H,0
	SHLD	PRG_NEWLINEPTR			; NEWLINE = 0
	SHLD	PRG_CURRPOSPTR			; CURRPOS = 0
	
	MVI	A,FALSE
	STA	PRG_INIF			; INIF = FALSE

	JMP	0$				; LOOP

5$:	; CHECK IF CURRLINE != 0
	LHLD	PRG_CURRLINEPTR			; CURRLINE IN HL
	MVI	A,0
	ORA	H
	ORA	L				; CHECK FOR ZERO
	JZ	100$
	
	LHLD	PRG_CURRLINEPTR			; CURR LINE IN HL
	MOV	E,M				; SIZE OF CURR LINE IN DE
	MVI	D,0				;
	
	MVI	A,0				; CHECK FOR SIZE ZERO (= LINE 0)
	CMP	E
	JZ	100$
	
	DAD	D				; CURRLINE += SIZE OF CURRLINE
	SHLD	PRG_CURRLINEPTR
	
	LXI	H,0
	SHLD	PRG_CURRPOSPTR			; CURRPOS = 0
	
	MVI	A,FALSE
	STA	PRG_INIF			; INIF = FALSE

	JMP	0$				; LOOP

100$:
	MVI	A,FALSE				; RESET SOME FLAGS
	STA	PRG_ISEND
	STA	PRG_INIF
	STA	PRG_CURRPOSPTR
	STA	PRG_CURRPOSPTR+1
		
	RET

;*********************************************************
;* RAM VARIABLES
;*********************************************************

.area	DATA	(REL,CON)

PRG_LOPTR::		.ds	2		; BOTTOM OF PROGRAM MEMORY
PRG_HIPTR::		.ds	2		; TOP OF PROGRAM MEMORY


PRG_CURRLINE::		.ds	2		; CURRENT LINE NUMBER

PRG_NEWLINEPTR:		.ds	2		; 
PRG_CURRLINEPTR:	.ds	2		; 
PRG_CURRPOSPTR:		.ds	2		; 

PRG_INIF:		.ds	1		; 
PRG_ISEND:		.ds	1		; 
PRG_ISNEXT:		.ds	1		; 
