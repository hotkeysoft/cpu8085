;*********************************************************
;* MODULE:	STRINGS
;* 
;* DESCRIPTION:	IMPLEMENTATION OF STRING HANDLING FUNCTIONS
;*		SUCH AS ALLOCATE, FREE, COMPARE, ETC
;*
;* $Id: strings.asm,v 1.24 2001-12-03 05:06:33 Dominic Thibodeau Exp $
;*

.module 	strings
.title 		Strings module

.include	'..\common\common.def'
.include	'..\program\program.def'
.include	'..\variables\variable.def'
.include	'..\error\error.def'
.include	'..\io\io.def'

.area	_CODE

;*********************************************************
;* STR_ALLOCATE:	ALLOCATES SPACE FOR A STRING
;*			IN: LENGTH IN ACC
;*			    'PARENT' PTR IN 'BC'
;*			RETURNS ADDRESS IN (H-L)
STR_ALLOCATE::

	; CHECK FOR NULL STRING
	ORA	A
	JNZ	1$
	
	LXI	H,0
	RET
	
1$:	; NOT NULL

	PUSH	D
	
	; KEEP SIZE
	PUSH	PSW
	
	ADI	3				; ADD 3 TO LENGTH
						; (STRLEN + REF PTR)
	; CALCULATE -ACC
	CMA					; ACC = ~ACC
	INR	A				; ACC = ~ACC+1

	LHLD	STR_LOPTR			; LOAD LO STR PTR
	MVI	D,0xFF	
	MOV	E,A				; -LEN IN DE
2$:		
	DAD	D				; LO STR PTR -= LEN
	
	; CHECK IF ENOUGH SPACE FOR ALLOCATION
	; (LO STRPTR) > (HI VARPTR)	
	LDA	VAR_HIPTR+1			; HI BYTE OF HIVARPTR
	CMP	H				; COMPARE WITH STR PTR
	JB	3$				; OK IF BELOW
	JNZ	4$				; NOT OK IF ABOVE
	
	; HI PTRS ARE EQUAL, CHECK LOW
	LDA	VAR_HIPTR			; LO BYTE OF HIVARPTR
	CMP	L				; COMPARE WITH STR PTR
	JB	3$				; OK IF BELOW
	JMP	4$
	
3$:
	
	SHLD	STR_LOPTR			; SAVE LO STR PTR
	
	MOV	M,C				; LO BYTE 'PARENT'
	INX	H
	
	MOV	M,B				; HI BYTE 'PARENT'
	INX	H
	
	POP	PSW				; GET BACK LENGTH
	
	MOV	M,A				; STORE LENGTH
	INX	H
	
	POP	D
	RET
	
4$:	; NOT ENOUGH MEMORY - TRY TO FREE SOME
	CALL	STR_GARBAGECOLLECTION
	JNC	ERR_OUTOFMEMORY			; REALLY OUT OF MEMORY
	
	LHLD	STR_LOPTR			; LOAD NEW STR PTR
	JMP	2$				; TRY AGAIN


;*********************************************************
;* STR_FREE:	FREE STR AT (H-L) (SETS 'PARENT' TO 0)
STR_FREE::
	PUSH	D
	PUSH	H				; KEEP ADDRESS
	
	XCHG					; SWAP HL<->DE
	LHLD	STR_LOPTR			; BOTTOM OF STR PTR IN HL
	XCHG					; SWAP HL<->DE
	
	; COMPARE STRPTR WITH STR_LOPTR
	; (ONLY FREE IF STRPTR > STR_LOPTR)
	MOV	A,H				; COMPARE HI BYTE
	CMP	D
	JB	2$
	JNZ	1$
	
	; HI BYTE ARE EQUAL
	MOV	A,L				; COMPARE LO BYTE
	CMP	E
	JB	2$

1$:	; 'FREE' STRING
	DCX	H
	DCX	H
	MVI	M,0
	DCX	H
	MVI	M,0
	
2$:	
	POP	H				; RESTORE ADDRESS
	POP	D
	RET
	
;*********************************************************
;* STR_COPY:	COPY STRING, LENGTH IN B
;*		SOURCE:	DE
;*		DEST: 	HL
STR_COPY::

	ORA	A				; CHECK LENGTH > 0
	RZ

1$:
	LDAX	D				; SOURCE IN ACC
	MOV	M,A				; COPY TO DEST
	
	INX	D				; SOURCE++
	INX	H				; DEST++
	DCR	B				; COUNTER--
	JNZ	1$				; LOOP
	
	RET

;*********************************************************
;* STR_CMP:	COMPARE STRINGS
;*		STR1:	DE, LEN: B
;*		STR2: 	HL, LEN: C
;* RESULTS:  ACC = 0x00 -> SAME
;*	     ACC = 0x01 -> STR1 > STR2
;*	     ACC = 0xFF -> STR1 < STR2
;*
STR_CMP::

1$:	
	; CHECK FOR END OF STRING
	MOV	A,B				; LEN1 IN ACC
	ORA	A				; CHECK FOR 0
	JZ	3$

	MOV	A,C				; LEN2 IN ACC
	ORA	A				; CHECK FOR 0
	JZ	3$
	
	; COMPARE TWO CHARS
	LDAX	D				; CURR STR1 CHAR IN ACC
	CMP	M				; COMPARE WITH STR2 CHAR
	
	JZ	2$
	JB	5$
	JMP	6$
	
2$:	; THE TWO CHARS ARE EQUAL
	INX	D				; STR1PTR++
	INX	H				; STR2PTR++
	DCR	B				; LENGTH1--
	DCR	C				; LENGTH2--
	JMP	1$
	
	
3$:	; END OF AT LEAST ONE STRING
	MOV	A,B				; LEN1 IN ACC
	ORA	A				; CHECK FOR ZERO
	JNZ	6$	
	
	MOV	A,C				; LEN2 IN ACC
	ORA	A				; CHECK FOR ZERO
	JNZ	5$
	

4$:	; EQUAL, RETURN 0
	MVI	A,0
	RET

5$:	; LESS, RETURN -1
	MVI	A,0xFF
	RET

6$:	; MORE, RETURN +1
	MVI	A,0x01
	RET

;*********************************************************
;* STR_GETUNIQUEPTR: CHECK WHERE THE STRING PTR RECEIVED 
;*		     LIES IN MEMORY.  COPY IF NEEDED,
;*		     RETURN 'GOOD' POINTER
;*		     IN: BC = SOURCE STRING PTR
;*		     IN: DE = PARENT PTR
;*		     OUT: PTR IN BC
STR_GETUNIQUEPTR::
	; CHECK IF STRING = NULL
	MVI	A,0
	ORA	B
	ORA	C
	RZ					; NOTHING TO DO

	PUSH	D
	PUSH	H

	LHLD	STR_LOPTR

	; COMPARE STRPTR WITH STR_LOPTR
	; (CHECK IF IN STRING AREA)
	MOV	A,B				; COMPARE HI BYTE
	CMP	H
	JB	2$
	JNZ	1$
	
	; HI BYTE ARE EQUAL
	MOV	A,C				; COMPARE LO BYTE
	CMP	L
	JB	2$

1$:	; STRING IS IN STR AREA
	DCX	B
	DCX	B
	
	; CHECK IF PARENT == 0
	LDAX	B
	ORA	A
	JNZ	4$
	DCX	B
	LDAX	B
	ORA	A
	JNZ	3$

	; ASSIGN THE STRING (NO PARENT)
	MOV	A,E
	STAX	B
	INX	B
	MOV	A,D
	STAX	B
	INX	B
	INX	B
	JMP	100$

2$:	; STRING IS LOWER THAN STRING AREA

	; MUST CHECK IF STRING IS LOWER THAN 
	; PROGRAM AREA.  IF SO, IT IS IN A TEMP
	; BUFFER AND MUST BE COPIED
	LHLD	PRG_LOPTR
	INR	H

	; COMPARE STRPTR WITH PRG_LOPTR
	; (CHECK IF IN PROGRAM AREA)
	MOV	A,B				; COMPARE HI BYTE
	CMP	H
	JB	5$
	JNZ	100$
	
	; HI BYTE ARE EQUAL
	MOV	A,C				; COMPARE LO BYTE
	CMP	L
	JB	5$
	JMP	100$

3$:
	INX	B
4$:
	INX	B
	INX	B
5$:	; COPY THE STRING

	; SWAP BC<->DE
	MOV	A,B
	MOV	B,D
	MOV	D,A
	MOV	A,C
	MOV	C,E
	MOV	E,A
	
	DCX	D
	LDAX	D				; READ SIZE OF STR IN ACC
	INX	D
	
	CALL	STR_ALLOCATE			; NEW STRING -> PTR IN HL
	PUSH	H				; KEEP ADDRESS
	
	MOV	B,A
	CALL	STR_COPY			; COPY THE STRING
	
	POP	B				; GET BACK ADDRESS
		
	JMP	100$

100$:
	POP	H
	POP	D
	RET


.if DEBUG
STR_DUMPSTRINGS::
	PUSH	B
	PUSH	D
	PUSH	H
	
	LHLD	STR_HIPTR
	XCHG
	LHLD	STR_LOPTR
	
1$:
	MOV	A,E
	CMP	L
	JNZ	2$
	
	MOV	A,D
	CMP	H
	JNZ	2$
	
	CALL	IO_PUTCR	
	POP	H
	POP	D
	POP	B
	RET		
	
2$:
	MVI	A,'[
	CALL	IO_PUTC

	INX	H
	INX	H
	INX	H
	CALL	IO_PUTHLHEX
	DCX	H
	DCX	H
	DCX	H

	MVI	A,']
	CALL	IO_PUTC

	MVI	A,' 
	CALL	IO_PUTC


	MVI	A,'(
	CALL	IO_PUTC
	
	MOV	C,M			; READ LO BYTE (PARENT)
	INX	H
	MOV	B,M			; READ HI BYTE (PARENT)
	INX	H
	
	MOV	A,B
	CALL	IO_PUTCH		; PRINT PARENT PTR
	MOV	A,C
	CALL	IO_PUTCH
	
	MVI	A,')
	CALL	IO_PUTC	

	MVI	A,' 
	CALL	IO_PUTC
	MVI	A,'"
	CALL	IO_PUTC
	
	MOV	B,M			; READ SIZE
	INX	H
	CALL	IO_PUTSN		; PRINT STRING
	
	MVI	A,'"
	CALL	IO_PUTC
	CALL	IO_PUTCR

	JMP	1$
.endif

;*********************************************************
;* STR_GARBAGECOLLECTION:
;*	OUT: CF = 1 IF ABLE TO FREE SOME MEMORY ELSE 0
STR_GARBAGECOLLECTION::
	PUSH	B
	PUSH	D
	PUSH	H

.if DEBUG
	LXI	H,GCSTR
	CALL	IO_PUTS
	CALL	IO_PUTCR
.endif

	LHLD	STR_LOPTR		; HL = BOTTOM OF STR MEMORY


LOOP1:	
	; CHECK IF END OF STR MEMORY
	LDA	STR_HIPTR		; LO BYTE
	CMP	L
	JNZ	OK
	LDA	STR_HIPTR+1		; HI BYTE
	CMP	H
	JZ	EXIT0
	
	
OK:	
	; FIND FIRST 'ORPHAN' STRING
	MOV	A,M			; CHECK FOR PARENT=0x0000
	ORA	A
	INX	H
	ORA	M
	JNZ	SKIP1
	
	; FOUND STRING WITH PARENT = 0x0000
	DCX	H
	SHLD	STR_GCLOPTR		; SAVE ADDRESS
	JMP	LOOP2
	
SKIP1:
	INX	H
	MVI	D,0
	MOV	E,M			; READ SIZE IN DE
	INX	H
	DAD	D			; HL = NEXT STRING
	JMP	LOOP1
	
	
LOOP2:	; FIND FIRST  NON-ORPHAN STRING

	; CHECK IF END OF STR MEMORY
	LDA	STR_HIPTR		; LO BYTE
	CMP	L
	JNZ	OK2
	LDA	STR_HIPTR+1		; HI BYTE
	CMP	H
	JNZ	OK2
	
	SHLD	STR_GCHIPTR
	JMP 	DOIT
	
OK2:	
	; FIND FIRST NON-ORPHAN STRING
	MOV	A,M			; CHECK FOR PARENT=0x0000
	ORA	A
	INX	H
	ORA	M
	JZ	SKIP2
	
	; FOUND STRING WITH PARENT != 0x0000
	DCX	H
	SHLD	STR_GCHIPTR		; SAVE ADDRESS
	JMP	DOIT

SKIP2:
	INX	H
	MVI	D,0
	MOV	E,M			; READ SIZE IN DE
	INX	H
	DAD	D			; HL = NEXT STRING
	JMP	LOOP2


DOIT:	; WE HAVE BEGIN AND END PTRS

	
	; CALCULATE SIZE OF THE BLOCK
	LHLD	STR_GCLOPTR		; PTR TO BOTTOM OF BLOCK
	XCHG				; IN DE
	LHLD	STR_GCHIPTR		; PTR TO TOP OF BLOCK IN HL
	
	; CALCULATE -LOPTR
	MOV	A,D
	CMA
	MOV	D,A
	
	MOV	A,E
	CMA
	MOV	E,A
	
	INX	D			; DE CONTAINS -IO_GCLOPTR
	
	DAD	D			; HL = HIPTR - LOPTR
	SHLD	STR_GCBLOCKSIZE		; SAVE FOR LATER
	
	;COPY DATA BLOCK
	LHLD	STR_GCLOPTR		; SOURCE
	XCHG				; IN DE
	LHLD	STR_GCHIPTR		; DEST IN HL

	LDA	STR_LOPTR		; READ STRLOPTR IN BC
	MOV	C,A
	LDA	STR_LOPTR+1
	MOV	B,A

COPYL:
	; CHECK IF SOURCE == STR_LOPTR
	MOV	A,C
	CMP	E
	JNZ	CONT
	
	MOV	A,B
	CMP	D
	JZ	CONT2
	
CONT:
	DCX	D			; SOURCE--
	DCX	H			; DEST--

	LDAX	D			; READ CURR BYTE
	MOV	M,A			; COPY TO DEST

	JMP	COPYL	
	
CONT2:	
	; UPDATE STRING AREA (LO PTR)
	LHLD	STR_GCBLOCKSIZE		; BLOCK SIZE
	XCHG				; IN DE
	LHLD	STR_LOPTR		; LO PTR IN HL
	DAD	D			; LOPTR += BLOCK SIZE
	SHLD	STR_LOPTR
	

	; UPDATE VARS CORRESPONDING TO STRINGS WHICH HAVE MOVED
	
	LHLD	VAR_HIPTR		; TOP OF VAR SPACE
	XCHG				; IN DE
	LHLD	VAR_LOPTR		; BOTTOM OF VAR SPACE IN HL
	
LOOP3:
	; CHECK FOR END
	MOV	A,L			; CHECK LO BYTE
	CMP	E
	JNZ	CONT3
	
	MOV	A,H			; CHECK HI BYTE
	CMP	D
	JZ	EXIT1
	
CONT3:
	MOV	A,M			; READ TAG[0]
	INX	H			; SKIP TAG[0]
	INX	H			; SKIP TAG[1]
	INX	H			; SKIP DATA[0]
	
	ORA	A			; CHECK IF STRING
	JP	CONT4
	
	MOV	C,M			; READ STR ADDRESS IN BC
	INX	H
	MOV	B,M
	INX	H

	; CHECK ADDRESS TO SEE IF WE MUST UPDATE PTR	

	LDA	STR_GCHIPTR+1		; LOAD HI BYTE OF HIPTR IN ACC
	CMP	B
	JB	LOOP3
	JNZ	OKK
	
	LDA	STR_GCHIPTR		; LOAD LO BYTE OF HIPTR IN ACC
	CMP	C
	JB	LOOP3	
	
OKK:
	MOV	A,B			; CHECK IF ADDR = 0
	ORA	B
	JZ	LOOP3			; SKIP IN THIS CASE
	
	PUSH	H
	LHLD	STR_GCBLOCKSIZE		; LOAD BLOCK SIZE
	DAD	B			; HL = PTR+OFFSET
	MOV	B,H			; COPY TO BC
	MOV	C,L
	POP	H
	
	DCX	H
	MOV	M,B			; PUT BACK LO BYTE
	DCX	H
	MOV	M,C			; PUT BACK HI BYTE
	
	INX	H
	INX	H

	JMP	LOOP3

CONT4:
	INX	H			; SKIP DATA[1]
	INX	H			; SKIP DATA[2]
	
	
	JMP	LOOP3
	
EXIT1:
	STC				; SET CARRY
	POP	H
	POP	D
	POP	B
	RET

EXIT0:
	ORA	A			; RESET CARRY
	POP	H
	POP	D
	POP	B
	RET

GCSTR:	.asciz	"Garbage Collection..."

;*********************************************************
;* RAM VARIABLES
;*********************************************************

.area	DATA	(REL,CON)

STR_LOPTR::		.ds	2		; BOTTOM OF STR MEMORY
STR_HIPTR::		.ds	2		; TOP OF STR MEMORY

STR_GCLOPTR:		.ds	2		; USED BY GARBAGE COLLECTOR
STR_GCHIPTR:		.ds	2		; USED BY GARBAGE COLLECTOR
STR_GCBLOCKSIZE:	.ds	2		; USED BY GARBAGE COLLECTOR