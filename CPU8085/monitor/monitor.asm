PAGE

STACK	EQU	$FFFF		SYSTEM STACK

KBD	EQU	$00		KEYBOARD PORT BASE

LCD	EQU	$20		LCD OUTPUT PORT BASE
LCDC	EQU	LCD+0		LCD CTRL PORT
LCDD	EQU 	LCD+1		LCD DATA PORT

TIMER	EQU	$40		TIMER PORT BASE
T_C0	EQU	TIMER+0		COUNTER 0
T_C1	EQU	TIMER+1		COUNTER 1
T_C2	EQU	TIMER+2		COUNTER 2
T_CWR	EQU	TIMER+3		CONTROL WORD REGISTER

UART	EQU	$60		UART PORT BASE
U_RBR	EQU	UART+0		RECEIVER BUFFER REGISTER (READ ONLY)
U_THR	EQU	UART+0		TRANSMITTER HOLDING REGISTER (WRITE ONLY)
U_IER	EQU	UART+1		INTERRUPT ENABLE REGISTER
U_IIR	EQU	UART+2		INTERRUPT IDENTIFICATION REGISTER (READ ONLY)
U_LCR	EQU	UART+3		LINE CONTROL REGISTER
U_MCR	EQU	UART+4		MODEM CONTROL REGISTER
U_LSR	EQU	UART+5		LINE STATUS REGISTER
U_MSR	EQU	UART+6		MODEM STATUS REGISTER
U_SCR	EQU	UART+7		SCRATCH REGISTER
U_DLL	EQU	UART+0		DIVISOR LATCH (LSB)
U_DLM	EQU 	UART+1		DIVISOR LATCH (MSB)

MISC	EQU	$80		MISC GATES

KBDUP		EQU	4
KBDRIGHT	EQU	5
KBDDOWN		EQU	6
KBDLEFT		EQU	7

KBLSHIFT	EQU	1
KBRSHIFT	EQU	2
KBCTRL		EQU	4
KBFUNC		EQU	8

* RAM VARIABLES
RAMBASE	EQU	$8000		RAM BASE

KBDTMP	EQU	RAMBASE		(1) KEYBOARD TMP VARIABLE FOR DEBOUNCING
KBDFLG	EQU	KBDTMP+1	(1) KEYBOARD FLAGS (SHIFT, CTRL AND FUNC)

BASE	EQU	KBDFLG+1	(2) BASE ADDRESS FOR MONITOR

INOUTF	EQU	BASE+2		(3) MEM AREA FOR "IN XX RET" OR "OUT XX RET"

TICNT	EQU	INOUTF+3	(2) TIMER COUNT


*********************************************************
* MAIN PROGRAM
*********************************************************
	ORG $00
RST0
	DI
	LXI	SP,STACK	INITALIZE STACK
	JMP START
	
*********************************************************	
	ORG $08
RST1

******delete
	DB $08
	DB $10
	DB $18
	DB $28
	DB $38
	DB $C8
*****end delete

	RET
	
*********************************************************
	ORG $10
RST2
	RET
	
	
*********************************************************
	ORG $18
RST3
	RET
	
*********************************************************
	ORG $20
RST4
	RET


*********************************************************
	ORG $24
RST45
	DI
	RET


*********************************************************
	ORG $28
RST5
	RET
	
*********************************************************
	ORG $2C
RST55
	DI
	RET
	
*********************************************************
	ORG $30
RST6
	RET

*********************************************************
	ORG $34
RST65
	DI
	JMP	INTUART
	
*********************************************************
	ORG $38
RST7
	RET

*********************************************************
	ORG $3C
RST75
	DI
	JMP	INTTI0

*********************************************************
	
START
	CALL	INITMISC	INITIALIZE MISC OUTPUTS
	CALL	INITTIMER	INITIALIZE TIMER
	CALL	INITUART	INITIALIZE UART	
	CALL	INITLCD		INITIALIZE LCD DISPLAY	
	CALL	INITKBD		INITIALIZE KEYBOARD
	
	MVI	A,8		SET INTERRUPT MASK
	SIM
	EI			ENABLE INTERRUPTS

	CALL	BEEP		MAKE SOME NOISE!
	
	CALL	INIT

	CALL	LCDCURON
	CALL	DISPLAY		DISPLAY MEMORY CONTENTS

LOOP
	CALL 	GETCHAR		GET A KEY

	ORA	A
	JZ	LOOP		LOOP WHILE NO KEY PRESS

* KEY WAS PRESSED
	CPI	KBDLEFT
	JNZ	NOLEFT
* LEFT: GO BACK ONE LINE (BASE = BASE-4)	

	MVI	A,4		4 BYTES
	JMP	DECBASE		UPDATE BASE
	
NOLEFT	
	CPI	KBDRIGHT
	JNZ	NORIGHT
* RIGHT: GO FORWARD ONE LINE (BASE = BASE+4)

	MVI	A,4		4 BYTES
	JMP	INCBASE		UPDATE BASE
	
NORIGHT
	CPI	KBDUP
	JNZ	NOUP
* UP: GO BACK 4 LINES (BASE = BASE-16)	

	MVI	A,16		4 BYTES
	JMP	DECBASE		UPDATE BASE
	
NOUP
	CPI	KBDDOWN
	JNZ	NODOWN
* DOWN: GO FORWARD 4 LINES (BASE = BASE+16)
	
	MVI	A,16		16 BYTES
	JMP	INCBASE		UPDATE BASE
	
NODOWN
	CPI	'G'
	JNZ	NOGOTO
	
* GOTO: ASK FOR ADDRESS AND GO TO IT
	CALL	LCDCLS		CLEAR SCREEN
	
	LXI	H,GOTOSTR	PRINT GOTO STRING
	CALL	LCDPUTS
	
	CALL 	GETHL		GET ADDRESS IN H-L
	JNC	SKIP		CY = 0 IF FAILED

	SHLD	BASE		H-L IN WORD AT 'BASE'
	JMP	SKIP	
	
NOGOTO
	CPI	'E'
	JNZ	NOEXEC
	
* EXEC: ASK FOR ADDRESS AND RUN IT
	CALL	LCDCLS		CLEAR SCREEN
	
	LXI	H,EXECSTR	PRINT EXEC STRING
	CALL	LCDPUTS
	
	CALL 	GETHL		GET ADDRESS IN H-L
	JNC	SKIP		CY = 0 IF FAILED

	PCHL			H&L TO PROGRAM COUNTER
	JMP	SKIP	

NOEXEC
	CPI	'I'
	JNZ	NOIN

* IN:	ASK WHICH PORT AND PRINT VALUE OF PORT

	CALL	LCDCLS		CLEAR SCREEN
	
	LXI	H,INSTR		PRINT INPUT STRING
	CALL	LCDPUTS
	
	CALL	GETBYTE		GET PORT # IN A
	JNC	SKIP		CY = 0 IF FAILED
	
	CALL	INPORTA		GET VALUE OF INPUT PORT 'A' IN 'A'
	
	LXI	H,$0001		NEXT LINE
	CALL	LCDGOTOXY
	
	LXI	H,INSTR2	PRINT INPUT STRING 2
	CALL	LCDPUTS
	
	CALL	LCDPUTCH	PRINT VALUE IN 'A' (HEX)
	
	CALL	WAITFORKEY	
	
	JMP	SKIP

NOIN
	CPI	'O'
	JNZ	NOOUT
	
* OUT:	ASK FOR PORT AND VALUE

	CALL	LCDCLS		CLEAR SCREEN
	
	LXI	H,OUTSTR	PRINT OUTPUT STRING
	CALL	LCDPUTS
	
	CALL	GETBYTE		GET PORT # IN A
	JNC	SKIP		CY = 0 IF FAILED
	
	MOV	B,A		PUT PORT # IN B
	
	LXI	H,$0001		NEXT LINE
	CALL	LCDGOTOXY
	
	LXI	H,OUTSTR2	PRINT INPUT STRING 2
	CALL	LCDPUTS

	CALL	GETBYTE		GET VALUE IN A
	JNC	SKIP		CY = 0 IF FAILED

	CALL	OUTPORTA	SET VALUE OF OUTPUT PORT #'B' TO 'A'
	
	JMP	SKIP

NOOUT	

	CPI	'V'
	JNZ	NOVERSION
	
* VERSION: PRINT VERSION NUMBER AND DATE
	CALL	LCDCLS		CLEAR SCREEN
	
	LXI	H,VERSIONSTR	PRINT VERSION STRING
	CALL	LCDPUTS

	CALL	WAITFORKEY	
	
	JMP	SKIP	
	
NOVERSION

	CPI	'B'
	JNZ	NOBEEP
	
* BEEP: MAKES A SOUND
	CALL	LCDCLS		CLEAR SCREEN
	
	LXI	H,BEEPSTR	PRINT BEEP STRING
	CALL	LCDPUTS
	
	CALL	GETBYTE		GET VALUE IN A
	JNC	SKIP		CY = 0 IF FAILED
	
	CALL	SOUNDON
	MVI	A,5		
	CALL 	DELAY		WAIT 5 * 100 MS
	CALL	SOUNDOFF

	JMP 	SKIP
	
NOBEEP	

	CPI	'D'
	JNZ	NODELAY
	
* DELAY: TESTS DELAY - WAITS USER DEFINED AMOUNT OF TIME
	CALL	LCDCLS		CLEAR SCREEN
	
	LXI	H,DELAYSTR	PRINT DELAY STRING
	CALL	LCDPUTS
	
	CALL	GETBYTE		GET VALUE IN A
	JNC	SKIP		CY = 0 IF FAILED
	
	CALL	BEEP
	CALL	DELAY
	CALL 	BEEP

	JMP 	SKIP
	
NODELAY

SKIP		
	CALL 	DISPLAY
	
	JMP 	LOOP		AD INFINITUM


INIT
	PUSH	H
	
	MVI	H,0
	MVI	L,0
	SHLD	BASE		BASE ADDRESS = 0
	
	POP	H
	RET
	
DISPLAY
	PUSH 	PSW
	PUSH	B
	PUSH	D
	PUSH	H
	
	CALL	LCDCLS		CLEAR SCREEN

	MVI	C,0		Y LOOP (0..3)

	LDA	BASE
	MOV	E,A
	LDA	BASE+1
	MOV	D,A
	
YLOOP	
	MVI	B,0		X = 0
	
	MVI	H,0		GOTOXY: 0,Y
	MOV	L,C
	CALL	LCDGOTOXY

* PRINT ADDRESS
	MVI	A,'('		PRINT ADDRESS IN FORMAT
	CALL	LCDPUTC		'(1234)'
	MOV	A,D
	CALL	LCDPUTCH
	MOV	A,E
	CALL	LCDPUTCH
	MVI	A,')'
	CALL	LCDPUTC

* GET MEMORY AT ADDRESS

XLOOP
	MVI	A,' '		PRINT SPACE
	CALL	LCDPUTC

	LDAX	D		GET BYTE AT D-E
	CALL	LCDPUTCH	PRINT IN HEX

	INX	D		INCREMENT ADDRESS

	INR	B		X++
	MOV	A,B
	CPI	4
	JNZ	XLOOP		X LOOP

	INR	C		Y++
	MOV	A,C
	CPI	4
	JNZ	YLOOP		Y LOOP

	POP	H
	POP	D
	POP	B
	POP 	PSW

	RET


INCBASE
	PUSH 	B
	PUSH	H
	
	LHLD	BASE		WORD AT 'BASE' IN H-L
	
	MOV	C,A		INCREMENT IN B-C
	MVI	B,0
	
	DAD	B		ADD TO H-L
	
	SHLD	BASE		H-L IN WORD AT 'BASE'
	
	POP	H
	POP	B
	JMP	SKIP		RETURN IN LOOP

DECBASE
	PUSH	PSW
	PUSH 	B
	PUSH	H
	
	LHLD	BASE		WORD AT 'BASE' IN H-L
	
* NEGATIVE VALUE IN B-C (TWO'S COMPLEMENT)
	
	CMA			COMPLEMENT A

	MOV	C,A		COMPLEMENT VALUE IN B-C
	MVI	B,255
	
	INX	B		ADD ONE TO B-C
	
	DAD	B		ADD TO H-L (EFFECTIVELY SUBSTRACTING A)
	
	SHLD	BASE		H-L IN WORD AT 'BASE'
	
	POP	H
	POP	B
	POP	PSW
	
	JMP	SKIP		RETURN IN LOOP

* PORT IN A
INPORTA
	PUSH	H
	
	LXI	H,INOUTF	FUNCTION BASE ADDRESS
	MVI	M,$DB		(IN)
	
	INX	H
	
	MOV	M,A		(PORT #)
	
	INX	H
	
	MVI	M,$C9		(RET)
	
	CALL	INOUTF		CALL NEW FUNCTION
	
	POP	H
	
	RET

* PORT IN B, VALUE IN A
OUTPORTA
	PUSH	H
	
	LXI	H,INOUTF	FUNCTION BASE ADDRESS
	MVI	M,$D3		(OUT)
	
	INX	H
	
	MOV	M,B		(PORT #)
	
	INX	H
	
	MVI	M,$C9		(RET)
	
	CALL	INOUTF		CALL NEW FUNCTION
	
	POP	H
	
	RET


*********************************************************
* UART ROUTINES
*********************************************************

*********************************************************
* INITUART:  INITIALIZES UART
INITUART
	PUSH	PSW
	
	MVI	A,$A0		SET DLA MODE
	OUT	U_LCR		
	
	MVI	A,$30		BAUD RATE SETUP
	OUT	U_DLL		2400 BAUDS
	MVI	A,$00		
	OUT	U_DLM
	
	MVI	A,$03		LCR SETUP
	OUT	U_LCR		8 DATA, 1 STOP, NO PARITY, DLA_OFF
	
	MVI	A,$01		INTERRUPT ENABLE REGISTER
	OUT	U_IER		ENABLE RECEIVED DATA AVAILABLE INTERRUPT
	
	POP	PSW
	RET

*********************************************************
* INTUART:  INTERRUPT HANDLER FOR UART
INTUART
	PUSH	PSW
	
	IN	U_RBR		GET THE BYTE
	OUT	U_THR		SEND IT BACK
	
	POP	PSW
	EI
	RET

*********************************************************
* TIMER ROUTINES
*********************************************************

*********************************************************
* INITTIMER:  INITIALIZES TIMERS
INITTIMER
	LXI	H,$0000		CLEAR H-L
	SHLD	TICNT		H-L IN WORD AT 'TICNT'

* SET COUNTER 0	

	MVI	A,$36		COUNTER 0, LSB+MSB, MODE 2, NOBCD
	OUT	T_CWR
	
* SOURCE:14400HZ,  DEST:10HZ, DIVIDE BY 1440 ($05A0)

	MVI	A,$A0		LSB
	OUT	T_C0
	
	MVI	A,$05		MSB
	OUT	T_C0
	
* ENABLE OUTPUT
	IN	MISC
	ORI	1		SET BIT 0
	OUT 	MISC	
	
* SET COUNTER 1

* SET COUNTER 2

	MVI	A,$B6		COUNTER 2, LSB+MSB, MODE 3, NOBCD
	OUT	T_CWR
	

	RET

*********************************************************
* INTTI0:  INTERRUPT HANDLER FOR TIMER 0. INCREMENTS TICNT
INTTI0
	PUSH	H
	
	LHLD	TICNT
	INX	H
	SHLD	TICNT
	POP	H
	
	EI
	RET


*********************************************************
* BEEP:  MAKES A 440HZ BEEP FOR 1/2 SECOND
BEEP
	PUSH 	PSW
	
	MVI	A,45		LA4 440HZ
	CALL	SOUNDON
	MVI	A,5		
	CALL 	DELAY		WAIT 5 * 100 MS
	CALL	SOUNDOFF
	
	POP	PSW
	RET

*********************************************************
* SOUNDON:  PROGRAMS COUNTER 0 AND ENABLES SOUND OUTPUT
SOUNDON
	PUSH 	PSW
	PUSH	B
	
	CALL	SOUNDOFF	TURNS OFF SOUND BEFORE REPROGRAMMING
	
	RLC			OFFSET *= 2 (TABLE CONTAINS WORDS)

	MVI	B,0
	MOV	C,A		OFFSET IN B-C
	
	LXI	H,NOTES		TABLE BASE IN H-L
	DAD	B		ADD OFFSET TO H-L
	
	MOV	A,M		BYTE AT H-L IN A (NOTE LSB)
	
	OUT	T_C2		DIVIDER LSB TO COUNTER
	
	INX	H		H-L POINTS TO NEXT BYTE
	MOV	A,M		BYTE AD H-L IN A (NOTE MSB)
	
	OUT	T_C2		DIVIDER MSB TO COUNTER	
	
	IN	MISC		INPUT MISC REGISTER
	ORI	$04		TURNS ON BIT 2
	OUT	MISC		OUTPUT MISC REGISTER
	
	POP	B
	POP	PSW	
	RET

*********************************************************
* SOUNDOFF:  DISABLES SOUND OUTPUT
SOUNDOFF
	PUSH 	PSW
	
	IN	MISC		INPUT MISC REGISTER
	ANI	$FB		TURNS OFF BIT 2
	OUT	MISC		OUTPUT MISC REGISTER
	
	POP	PSW
	RET


*********************************************************
* MISC ROUTINES
*********************************************************

INITMISC
	PUSH	PSW
	MVI	A,0		ALL OUTPUTS LOW
	OUT	MISC
	POP	PSW
	RET


*********************************************************
* KEYBOARD ROUTINES
*********************************************************


INITKBD
	PUSH	H
	
	LXI	H,KBDTMP
	MVI	M,0
	
	LXI	H,KBDFLG
	MVI	M,0
	
	POP 	H
	RET

*********************************************************
* GETHL:  GETS A 16 BIT VALUE IN H-L, CY=1 IF EVERYTHING OK
GETHL	
	CALL	GETBYTE		GET FIRST BYTE
	RNC			IF BAD, DON'T WAIT FOR SECOND
	MOV	H,A		SAVE IN HIGH BYTE OF RESULT
	CALL	GETBYTE		GET SECOND BYTE
	MOV	L,A		SAVE IN LOW BYTE OF RESULT
	
	RET
	
*********************************************************
* GETBYTE: GETS A BYTE FOR ACC FROM KEYBOARD, CY=0 IF FAILS
GETBYTE	PUSH	B		SAVE B-C PAIR
	CALL	GETNIB		GEET FIRST NIBBLE
	JNC	RETGB		IF BAD, DON'T WAIT FOR MORE
	RLC			SHIFT INTO.
	RLC			UPPER NIBBLE.
	RLC			OF RESULT.
	RLC			SO WE CAN INSERT LOWER NIBBLE
	MOV	B,A		KEEP HIGH DIGIT IN B
	CALL	GETNIB		GET SECOND DIGIT
	JNC	RETGB		IF BAD, INDICATE SO
	ORA	B		INSERT HIGH DIGIT
	STC			INDICATE SUCESS
RETGB	POP	B		RESTORE B-C PAIR
	RET
	
*********************************************************
* GETNIB: GETS A NIBBLE FROM THE KEYBOARD (IN ASCII HEX)
GETNIB	CALL	GETCHAR		GET A CHARACTER
	CPI	' '		TEST FOR BLANK (ABORT1)
	RZ			IF SO, RETURN INDICATING BAD (CY=0)
	CPI	$0D		TEST FOR <CR> (ABORT2)
	RZ			IF SO, RETURN INDICATING BAD
	CPI	'0'		TEST FOR INVALID (BELOW '0')
	JC	GETNIB		IF SO, WAIT FOR MORE
	CPI	'G'		TEST FOR INVALID (GREATER THAN 'F')
	JNC	GETNIB		IF SO, IGNORE
	CALL	LCDPUTC		DISPLAY CHARACTER
	CPI	$3A		TEST FOR INVALID
	JC	NUMH		IF OK, WE ARE IN
	CPI	'A'		TEST FOR INVALID
	JC	GETNIB		IF BAD, IGNORE
	SUI	7		CONVERT TO DIGIT
NUMH	SUI	$30		CONVERT TO BINARY
	STC			INDICATE SUCESS
	RET

*********************************************************
* WAITFORKEY: WAIT UNTIL USER PRESSES ANY KEY
WAITFORKEY
	CALL 	GETCHAR		GET A KEY

	ORA	A
	JZ	WAITFORKEY	LOOP WHILE NO KEY PRESS
	
	RET	

*********************************************************
* GETCHAR
GETCHAR
	PUSH	H	SAVE H&L
	PUSH	B	SAVE B&C
	
	CALL 	KBREAD	READ ONCE
	MOV	B,A	MOVE IN B

	CALL	SDELAY	WAIT 
	
	CALL	KBREAD	READ ONE MORE TIME
	
	CMP	B	COMPARE RESULTS
	JZ	GETCHAR0
	
	MVI	A,0	RETURN 0
	JMP	GETCHAR2
	
GETCHAR0
	LXI	H,KBDTMP
	MOV	A,M	LOAD LAST CHAR STORED IN MEMORY
	
	CMP	B	COMPARE WITH THIS ONE
	JZ	GETCHAR1
	
	MOV	A,B	NEW CHAR IN A
	MOV	M,A	NEW CHAR IN MEM
	
	JMP 	GETCHAR2
	
GETCHAR1
	MVI	A,0	
	JMP	GETCHAR2
	
GETCHAR2
	POP	B	RESTORE B&C
	POP	H	RESTORE H&L
	RET

*********************************************************
* KBREAD, CHECK IF CHAR IS AVAILABLE FROM KEYBOARD.
* RETURNS CHAR VALUE IN A OR 0 IF NO CHAR IS AVAILABLE
* ** NOT DEBOUNCED **
KBREAD	
	PUSH	H	SAVE H&L
	PUSH	B	SAVE B&C
	
	MVI	B,0
	IN	KBD	
	ORA	A
	JNZ	KBDECODE
	
	MVI	B,1	
	IN	KBD+1
	ORA	A
	JNZ	KBDECODE	

	MVI	B,2
	IN	KBD+2
	CALL 	KBISSPECIAL	CHECK FOR CONTROL CHAR (CTRL)
	ORA	A
	JNZ	KBDECODE	

	MVI	B,3
	IN	KBD+3
	CALL 	KBISSPECIAL
	ORA	A
	JNZ	KBDECODE	

	MVI	B,4
	IN	KBD+4
	CALL	KBISSPECIAL	CHECK FOR SHIFT CHAR (LSHIFT)
	ORA	A
	JNZ	KBDECODE

	MVI	B,5
	IN	KBD+5
	CALL	KBISSPECIAL	CHECK FOR FUNCTION CHAR (FUNCT)
	ORA	A
	JNZ	KBDECODE	
	
	MVI	B,6	
	IN	KBD+6
	ORA	A
	JNZ	KBDECODE	

	MVI	B,7
	IN	KBD+7
	CALL	KBISSPECIAL	CHECK FOR FUNCTION CHAR (RSHIFT)
	ORA	A
	JNZ	KBDECODE	
	
* No char detected, return 0
	MVI	A,0	

	JMP	KBDEC5
	
* Char found, decode it
KBDECODE
	MVI	C,0
	
KBDEC1	
	RAL		ROTATE LEFT THROUGH CARRY
	JC 	KBDEC2	SET BIT WAS FOUND
	INR	C	INCREMENT POSITION COUNTER	
	JMP	KBDEC1
	
KBDEC2
	MOV	A,B	PORT NUMBER IN BITS 3-4-5
	RLC		SHIFT 3 BITS TO THE LEFT
	RLC
	RLC
	ANI	$38
	ORA	C	C IN LOW BITS (0-1-2), A NOW CONTAINS DECODED CHAR (6 bits)
	
	MVI	B,0	PUT 0,A in B,C
	MOV	C,A

* Must now translate to ASCII

	LXI	H,KBDFLG
	MOV	A,M			LOAD KEYBOARD FLAGS
	ANI	KBLSHIFT+KBRSHIFT	SHIFT (L OR R)?
	JNZ	KBDEC3
	
	LXI	H,KB2ASCL		LOAD LOW CHAR TABLE
	JMP	KBDEC4
KBDEC3
	LXI	H,KB2ASCH		LOAD HI CHAR TABLE
KBDEC4
	DAD	B
	MOV	A,M

KBDEC5
	POP	B	RESTORE B&C
	POP	H
	RET

*******************
KBISSPECIAL
	PUSH	PSW
	PUSH 	B
	PUSH 	H

	LXI	H,KBDFLG
	
	ANI	1	CLEAR ALL BUT LSB
	MOV	C,A	PUT RESULT IN C

* IDENTIFY FLAG AND SET/RESET IN KBDFLG
	MOV	A,B	PORT# IN A
	
	MVI	B,0

	CPI	2
	JNZ	KBNOCTRL
* CTRL
	MVI	B,KBCTRL
	
KBNOCTRL
	CPI	4
	JNZ	KBNOLSHIFT
* LEFT SHIFT	
	MVI	B,KBLSHIFT
	
KBNOLSHIFT
	CPI	5
	JNZ	KBNOFUNCT
* FUNC	
	MVI	B,KBFUNC
	
KBNOFUNCT
	CPI	7
	JNZ	KBNORSHIFT
* RIGHT SHIFT
	MVI	B,KBRSHIFT
	
KBNORSHIFT

* SET OR RESET?
	MOV	A,C	
	ORA	A	CHECK LSB
	JZ	KBRESET

* MUST SET FLAG
	MOV	A,M	LOAD FLAG IN A
	ORA	B	SET FLAG
	MOV	M,A

	JMP	KBISSPECIAL2
	
KBRESET
* MUST RESET FLAG
	MOV	A,B	PUT FLAG VALUE IN A
	CMA		INVERT BITS
	MOV	B,A	PUT BACK IN B
	
	MOV	A,M	LOAD FLAG IN A
	ANA	B	RESET FLAG
	
KBISSPECIAL2
	MOV	M,A	PUT BACK IN MEM
	
	POP	H
	POP	B
	POP	PSW
	
	ANI	254	CLEAR LSB	
	RET

*********************************************************
* LCD ROUTINES
*********************************************************

*********************************************************
* CLEAR SCREEN
LCDCLS
	PUSH	PSW

	CALL	LCDWAIT
	
	MVI	A,1		OUT DATA
	OUT	LCDC

	CALL	SDELAY
	CALL	SDELAY

	POP	PSW	
	RET

*********************************************************
* CURSOR ON
LCDCURON
	PUSH	PSW

	CALL	LCDWAIT
	
	MVI	A,15		OUT DATA
	OUT	LCDC
	
	POP	PSW	
	RET

*********************************************************
* CURSOR OFF
LCDCUROFF
	PUSH	PSW

	CALL	LCDWAIT
	
	MVI	A,12		OUT DATA
	OUT	LCDC
	
	POP	PSW	
	RET

*********************************************************
* GOTO XY
* X IN H (0..19), Y IN L (0..3)
LCDGOTOXY
	PUSH	PSW
	PUSH	H
	PUSH	B

	MOV	C,L		LINE IN C
	MOV	A,H		COL IN A

	LXI	H,GOTOXYOFS	OFFSET TABLE
	MVI	B,0
	
	DAD	B		INDEX IN TABLE
	
	MOV	B,M		ADDR IN B
	
	ADD	B		ADD TO X, COMPLETE ADDRESS IN NOW IN A
	
	ORI	$80		SET BIT 7

	CALL	LCDWAIT

	OUT	LCDC		
	
	POP	B
	POP	H
	POP	PSW
	
	RET

GOTOXYOFS
	DB	$0,$40,$14,$54

*********************************************************
* PUT STRING
* NULL-TERMINATED STRING IN H,L
LCDPUTS
	PUSH	PSW
	PUSH	H
	
LCDPUTS1
	MOV	A,M		LOAD CHAR FROM MEMORY
	ORA	A		END OF STRING?
	JZ	LCDPUTS2

	CALL 	LCDPUTC		PRINT CHAR
	
	INX	H		INCREMENT ADDRESS	
	
	JMP	LCDPUTS1	LOOP
	
LCDPUTS2
	POP	H
	POP	PSW
	RET
	

*********************************************************
* PUT CHAR
* CHAR IN A
LCDPUTC
	PUSH	PSW

	CALL	LCDWAIT
	
	OUT	LCDD		PUT A ON DATA PORT
	
	POP	PSW
	RET	

*********************************************************
* PUT CHAR (BINARY)
LCDPUTCB
	PUSH	PSW
	PUSH	B
	
	MOV	C,A		KEEP IN NUMBER IN C
	
	MVI	B,8		8 BINARY DIGITS
LCDPUTB0
	MOV	A,C		GET NUMBER
	RAL			SHIFT LEFT
	MOV	C,A		PUT BACK IN C
	JC	LCDPUTB1	0 OR 1?
	
	MVI	A,'0'		WE HAVE A ZERO
	JMP 	LCDPUTB2	
LCDPUTB1	
	MVI	A,'1'		WE HAVE A ONE
	
LCDPUTB2
	CALL	LCDPUTC		PRINT THE BIT

	DCR	B		LOOP FOR 8 BITS
	JNZ	LCDPUTB0
	
	POP	B
	POP	PSW
	RET

*********************************************************
* PUTHL (HEX) SHOW 16 BIT VALUE OF HL IN HEX
LCDPUTHL
	PUSH 	PSW
	MOV	A,H		GET H
	CALL	LCDPUTCH	DISPLAY H IN HEX
	MOV	A,L		GET L
	CALL	LCDPUTCH	DISPLAY L IN HEX
	POP	PSW
	RET
	
*********************************************************	
* DISPLAYS 8 BIT VALUE OF A IN HEX
LCDPUTCH
	PUSH	PSW		SAVE LOW DIGIT
	RRC			MAKE HIGH.
	RRC			DIGIT.
	RRC			INTO.
	RRC			LOW DIGIT.
	CALL	LCDPUTN		PRINT HIGH DIGIT
	POP	PSW		GET LOW DIGIT BACK
	CALL	LCDPUTN		PRINT LOW DIGIT
	RET
	
*********************************************************	
* LCDPUTN DISPLAYS NIBBLE IN LOWER 4 BITS OF A ('0'..'F')
LCDPUTN	
	PUSH	PSW
	ANI	$0F		GET RID OF EXCESS BAGGAGE
	ADI	$30		CONVERT TO ASCII NUMBER
	CPI	$3A		TEST FOR ALPHA CHARACTER
	JC	LCDPUTN2	IF NOT, WE ARE OK
	ADI	7		CONVERT TO CHARACTER
LCDPUTN2	
	CALL	LCDPUTC
	POP	PSW
	RET

*********************************************************
* INITIALIZE LCD MODULE
INITLCD	
	PUSH	PSW
	
	CALL	SDELAY
	CALL	SDELAY
	CALL	SDELAY
	CALL	SDELAY
	CALL	SDELAY
	CALL	SDELAY
	CALL	SDELAY
	CALL	SDELAY
	CALL	SDELAY
	CALL	SDELAY
	
	MVI	A,$30
	OUT	LCDC

	CALL	SDELAY
	CALL	SDELAY
		
	OUT	LCDC
		
	CALL 	SDELAY	
	
	OUT	LCDC
	
	CALL 	SDELAY	

* Function set
	MVI	A,$38		
	OUT	LCDC
	
	CALL 	SDELAY	

* Display OFF
	MVI	A,$08		
	OUT	LCDC
	
	CALL 	SDELAY	

* Display ON	
	MVI	A,$01		
	OUT	LCDC
	
	CALL 	SDELAY	
	
	MVI	A,$0C
	OUT	LCDC
	
	CALL	SDELAY

	MVI	A,$06
	OUT	LCDC

	CALL	SDELAY
	CALL	SDELAY

	POP	PSW
	RET

*********************************************************
* CHECKS LCD BUSY FLAG - RETURNS WHEN 0
LCDWAIT
	PUSH 	PSW
LCDW1
	IN	LCDC
	RAL		ROTATE LEFT THROUGH CARRY
	JNC	LCDW2
	JMP	LCDW1
	
LCDW2	POP	PSW
	RET

*********************************************************
* General purpose functions
*********************************************************

*********************************************************
* DELAY, WAITS ACC * 100MS
DELAY	PUSH 	PSW
	PUSH 	H
	PUSH	D

	LHLD	TICNT		LOAD CURRENT COUNT IN H-L

	MOV	E,A		COUNT IN D-E
	MVI	D,0
	
	DAD	D		ADD TO H-L
	
	XCHG			EXCHANGE D&E, H&L, TARGET NOW IN D-E
	
DLOOP	LHLD	TICNT		LOAD CURRENT COUNT IN H-L

	MOV	A,H		MSB IN A
	XRA	D		COMPARE WITH MSB OF TARGET
	JNZ	DLOOP		DIFFERENT -> LOOP
	
	MOV	A,L		LSB IN A
	XRA	E		COMPARE WITH LSB OF TARGET
	JNZ	DLOOP		DIFFERENT -> LOOP	
	
* WE ARE DONE!
	
	POP	D
	POP	H
	POP 	PSW
	RET

*********************************************************
* SDELAY, WAITS A FINITE TIME INTERVAL (approx 2ms)
SDELAY	PUSH	PSW
	PUSH	H		SAVE H-L
	LXI	H,$004C		START COUNTING
DEL1	DCX	H		REDUCE COUNT
	MOV	A,H		GET HIGH VALUE
	ORA	L		TEST FOR ZERO WITH LOW VALUE
	JNZ	DEL1		IF NOT, KEEP COUNTING
	POP	H		RESTORE H-L
	POP	PSW
	RET


KB2ASCL	DB	'7','n','5','v','3','x','1',0
	DB	'j','t','r','f','d','q',27,0
	DB	'm','6','b','4','c','2','z',0
	DB	'k','9',';',')','%','<',0,0
	DB	' ',',',':',4,5,6,7,1
	DB	'u','i','o','p','{','$',8,0
	DB	'y','h','g','e','w','s','a',0
	DB	'8','l','0','=','-',0,13,1

KB2ASCH	DB	'\','N','(','V','"','X','&',0
	DB	'J','T','R','F','D','Q','~',0
	DB	'M','`','B',39,'C','/','Z',0
	DB	'K','[','.','?','|','>',0,0
	DB	' ','?','@',4,5,6,7,1
	DB	'U','I','O','P','}','*','#',0
	DB	'Y','H','G','E','W','S','A',0
	DB	'!','L',']','+','^',0,13,1
	
NOTES	DW	$DC29,$CFCE,$C424,$B922,$AEBE,$A4EF,$9BAE,$92F1,$8AB1,$82E9,$7B90,$74A0
	DW	$6E15,$67E7,$6212,$5C91,$575F,$5278,$4DD7,$4978,$4559,$4174,$3DC8,$3A50
	DW	$370A,$33FA,$3109,$2E49,$2BB0,$293C,$26EB,$24BC,$22AC,$20BA,$1EE4,$1D28
	DW	$1B85,$19FA,$1885,$1724,$15D8,$149E,$1376,$125E,$1156,$105D,$0F72,$0E94
	DW	$0DC3,$0CFD,$0C42,$0B92,$0AEC,$0A4F,$09BB,$092F,$08AB,$082F,$07B9,$074A
	DW	$06E1,$067E,$0621,$05C9,$0576,$0527,$04DD,$0498,$0456,$0417,$03DC,$03A5
	DW	$0371,$033F,$0311,$02E5,$02BB,$0294,$026F,$024C,$022B,$020C,$01EE,$01D3

	
GOTOSTR	STRZ	'Goto: '
EXECSTR STRZ	'Exec: '

INSTR	STRZ	'Input - Port: '
INSTR2	STRZ	'       Value: '

OUTSTR	STRZ	'Output - Port: '
OUTSTR2	STRZ	'        Value: '

BEEPSTR	STRZ	'Beep - Note: '

DELAYSTR
	STRZ	'Delay - 100mS X: '

RIMSTR	STRZ	'RIM: '
SIMSTR	STRZ	'SIM: '

VERSIONSTR STRZ 'Monitor V0.0.1'

INTSTR	STRZ	'Interrupt!'