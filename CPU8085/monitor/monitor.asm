.module 	monitor
.title 		Monitor

.include	'..\basic\io\io.def'
.include	'..\basic\fbuffer\fbuffer.def'

STACK		=	0xFFFF		;SYSTEM STACK

KBD		=	0x00		;KEYBOARD PORT BASE

LCD		=	0x20		;LCD OUTPUT PORT BASE
LCDC		=	LCD+0		;LCD CTRL PORT
LCDD		= 	LCD+1		;LCD DATA PORT

KBDUP		=	4
KBDRIGHT	=	5
KBDDOWN		=	6
KBDLEFT		=	7

KBLSHIFT	=	1
KBRSHIFT	=	2
KBCTRL		=	4
KBFUNC		=	8

.area	BOOT	(ABS)

.org 	0x0000

RST0:
	DI
	LXI	SP,STACK	;INITALIZE STACK
	JMP 	START
	
;*********************************************************
;* MAIN PROGRAM
;*********************************************************
.area 	_CODE

START:
	CALL	INITLCD		;INITIALIZE LCD DISPLAY	
	CALL	INITKBD		;INITIALIZE KEYBOARD
	CALL	IO_INIT		;INITIALIZE IO
	CALL	FB_INIT		;INITIALIZE FRAME BUFFER
	
	MVI	A,8		;SET INTERRUPT MASK
	SIM
	EI			;ENABLE INTERRUPTS

	CALL	IO_BEEP		;MAKE SOME NOISE!
	
	CALL	INIT

	CALL	LCDCURON
	CALL	DISPLAY		;DISPLAY MEMORY CONTENTS

LOOP:
	CALL	IO_GETCHAR	;CHECK TERMINAL
	ORA	A
	JZ	CONT
	
	CALL	FB_PUTC		;SEND BACK
	
CONT:

	CALL 	GETCHAR		;GET A KEY

	ORA	A
	JZ	LOOP		;LOOP WHILE NO KEY PRESS

; KEY WAS PRESSED
	CPI	KBDLEFT
	JNZ	NOLEFT
; LEFT: GO BACK ONE LINE (BASE = BASE-4)	

	MVI	A,4		;4 BYTES
	JMP	DECBASE		;UPDATE BASE
	
NOLEFT:
	CPI	KBDRIGHT
	JNZ	NORIGHT
; RIGHT: GO FORWARD ONE LINE (BASE = BASE+4)

	MVI	A,4		;4 BYTES
	JMP	INCBASE		;UPDATE BASE
	
NORIGHT:
	CPI	KBDUP
	JNZ	NOUP
; UP: GO BACK 4 LINES (BASE = BASE-16)	

	MVI	A,16		;4 BYTES
	JMP	DECBASE		;UPDATE BASE
	
NOUP:
	CPI	KBDDOWN
	JNZ	NODOWN
; DOWN: GO FORWARD 4 LINES (BASE = BASE+16)
	
	MVI	A,16		;16 BYTES
	JMP	INCBASE		;UPDATE BASE
	
NODOWN:
	CPI	'G
	JNZ	NOGOTO
	
; GOTO: ASK FOR ADDRESS AND GO TO IT
	CALL	LCDCLS		;CLEAR SCREEN
	
	LXI	H,GOTOSTR	;PRINT GOTO STRING
	CALL	LCDPUTS
	
	CALL 	GETHL		;GET ADDRESS IN H-L
	JNC	SKIP		;CY = 0 IF FAILED

	SHLD	BASE		;H-L IN WORD AT 'BASE'
	JMP	SKIP	
	
NOGOTO:
	CPI	'E
	JNZ	NOEXEC
	
; EXEC: ASK FOR ADDRESS AND RUN IT
	CALL	LCDCLS		;CLEAR SCREEN
	
	LXI	H,EXECSTR	;PRINT EXEC STRING
	CALL	LCDPUTS
	
	CALL 	GETHL		;GET ADDRESS IN H-L
	JNC	SKIP		;CY = 0 IF FAILED

	PCHL			;H&L TO PROGRAM COUNTER
	JMP	SKIP	

NOEXEC:
	CPI	'I
	JNZ	NOIN

; IN:	ASK WHICH PORT AND PRINT VALUE OF PORT

	CALL	LCDCLS		;CLEAR SCREEN
	
	LXI	H,INSTR		;PRINT INPUT STRING
	CALL	LCDPUTS
	
	CALL	GETBYTE		;GET PORT # IN A
	JNC	SKIP		;CY = 0 IF FAILED
	
	CALL	INPORTA		;GET VALUE OF INPUT PORT 'A' IN 'A'
	
	LXI	H,0x0001	;NEXT LINE
	CALL	LCDGOTOXY
	
	LXI	H,INSTR2	;PRINT INPUT STRING 2
	CALL	LCDPUTS
	
	CALL	LCDPUTCH	;PRINT VALUE IN 'A' (HEX)
	
	CALL	WAITFORKEY	
	
	JMP	SKIP

NOIN:
	CPI	'O
	JNZ	NOOUT
	
; OUT:	ASK FOR PORT AND VALUE

	CALL	LCDCLS		;CLEAR SCREEN
	
	LXI	H,OUTSTR	;PRINT OUTPUT STRING
	CALL	LCDPUTS
	
	CALL	GETBYTE		;GET PORT # IN A
	JNC	SKIP		;CY = 0 IF FAILED
	
	MOV	B,A		;PUT PORT # IN B
	
	LXI	H,0x0001	;NEXT LINE
	CALL	LCDGOTOXY
	
	LXI	H,OUTSTR2	;PRINT INPUT STRING 2
	CALL	LCDPUTS

	CALL	GETBYTE		;GET VALUE IN A
	JNC	SKIP		;CY = 0 IF FAILED

	CALL	OUTPORTA	;SET VALUE OF OUTPUT PORT #'B' TO 'A'
	
	JMP	SKIP

NOOUT:
	CPI	'V
	JNZ	NOVERSION
	
; VERSION: PRINT VERSION NUMBER AND DATE
	CALL	LCDCLS		;CLEAR SCREEN
	
	LXI	H,VERSIONSTR	;PRINT VERSION STRING
	CALL	LCDPUTS

	CALL	WAITFORKEY	
	
	JMP	SKIP	
	
NOVERSION:

	CPI	'B
	JNZ	NOBEEP
	
; BEEP: MAKES A SOUND
	CALL	LCDCLS		;CLEAR SCREEN
	
	LXI	H,BEEPSTR	;PRINT BEEP STRING
	CALL	LCDPUTS
	
	CALL	GETBYTE		;GET VALUE IN A
	JNC	SKIP		;CY = 0 IF FAILED
	
	CALL	IO_SOUNDON
	MVI	A,5		
	CALL 	IO_DELAY	;WAIT 5 * 100 MS
	CALL	IO_SOUNDOFF

	JMP 	SKIP
	
NOBEEP:	

	CPI	'D
	JNZ	NODELAY
	
; DELAY: TESTS DELAY - WAITS USER DEFINED AMOUNT OF TIME
	CALL	LCDCLS		;CLEAR SCREEN
	
	LXI	H,DELAYSTR	;PRINT DELAY STRING
	CALL	LCDPUTS
	
	CALL	GETBYTE		;GET VALUE IN A
	JNC	SKIP		;CY = 0 IF FAILED
	
	CALL	IO_BEEP
	CALL	IO_DELAY
	CALL 	IO_BEEP

	JMP 	SKIP
	
NODELAY:

	CPI	'g
	JNZ	NOGET
	
; GET: GET CHAR FROM KB BUFFER
	CALL	IO_GETCHAR
	
	JMP	SKIP	

NOGET:

SKIP:		
	CALL 	DISPLAY
	
	JMP 	LOOP		;AD INFINITUM


INIT:
	PUSH	H
	
	MVI	H,0
	MVI	L,0
	SHLD	BASE		;BASE ADDRESS = 0
	
	POP	H
	RET
	
DISPLAY:
	PUSH 	PSW
	PUSH	B
	PUSH	D
	PUSH	H
	
	CALL	LCDCLS		;CLEAR SCREEN

	MVI	C,0		;Y LOOP (0..3)

	LDA	BASE
	MOV	E,A
	LDA	BASE+1
	MOV	D,A
	
YLOOP:	
	MVI	B,0		;X = 0
	
	MVI	H,0		;GOTOXY: 0,Y
	MOV	L,C
	CALL	LCDGOTOXY

; PRINT ADDRESS
	MVI	A,#'(		;PRINT ADDRESS IN FORMAT
	CALL	LCDPUTC		;'(1234)'
	MOV	A,D
	CALL	LCDPUTCH
	MOV	A,E
	CALL	LCDPUTCH
	MVI	A,#')
	CALL	LCDPUTC

; GET MEMORY AT ADDRESS

XLOOP:
	MVI	A,#' 		;PRINT SPACE
	CALL	LCDPUTC

	LDAX	D		;GET BYTE AT D-E
	CALL	LCDPUTCH	;PRINT IN HEX

	INX	D		;INCREMENT ADDRESS

	INR	B		;X++
	MOV	A,B
	CPI	4
	JNZ	XLOOP		;X LOOP

	INR	C		;Y++
	MOV	A,C
	CPI	4
	JNZ	YLOOP		;Y LOOP

	POP	H
	POP	D
	POP	B
	POP 	PSW

	RET


INCBASE:
	PUSH 	B
	PUSH	H
	
	LHLD	BASE		;WORD AT 'BASE' IN H-L
	
	MOV	C,A		;INCREMENT IN B-C
	MVI	B,0
	
	DAD	B		;ADD TO H-L
	
	SHLD	BASE		;H-L IN WORD AT 'BASE'
	
	POP	H
	POP	B
	JMP	SKIP		;RETURN IN LOOP

DECBASE:
	PUSH	PSW
	PUSH 	B
	PUSH	H
	
	LHLD	BASE		;WORD AT 'BASE' IN H-L
	
; NEGATIVE VALUE IN B-C (TWO'S COMPLEMENT)
	
	CMA			;COMPLEMENT A

	MOV	C,A		;COMPLEMENT VALUE IN B-C
	MVI	B,255
	
	INX	B		;ADD ONE TO B-C
	
	DAD	B		;ADD TO H-L (EFFECTIVELY SUBSTRACTING A)
	
	SHLD	BASE		;H-L IN WORD AT 'BASE'
	
	POP	H
	POP	B
	POP	PSW
	
	JMP	SKIP		;RETURN IN LOOP

; PORT IN A
INPORTA:
	PUSH	H
	
	LXI	H,INOUTF	;FUNCTION BASE ADDRESS
	MVI	M,0xDB		;(IN)
	
	INX	H
	
	MOV	M,A		;(PORT #)
	
	INX	H
	
	MVI	M,0xC9		;(RET)
	
	CALL	INOUTF		;CALL NEW FUNCTION
	
	POP	H
	
	RET

; PORT IN B, VALUE IN A
OUTPORTA:
	PUSH	H
	
	LXI	H,INOUTF	;FUNCTION BASE ADDRESS
	MVI	M,0xD3		;(OUT)
	
	INX	H
	
	MOV	M,B		;(PORT #)
	
	INX	H
	
	MVI	M,0xC9		;(RET)
	
	CALL	INOUTF		;CALL NEW FUNCTION
	
	POP	H
	
	RET

;********************************************************
; KEYBOARD ROUTINES
;********************************************************
INITKBD:
	PUSH	H
	
	LXI	H,KBDTMP
	MVI	M,0
	
	LXI	H,KBDFLG
	MVI	M,0
	
	POP 	H
	RET

;********************************************************
; GETHL:  GETS A 16 BIT VALUE IN H-L, CY=1 IF EVERYTHING OK
GETHL:
	CALL	GETBYTE		;GET FIRST BYTE
	RNC			;IF BAD, DON'T WAIT FOR SECOND
	MOV	H,A		;SAVE IN HIGH BYTE OF RESULT
	CALL	GETBYTE		;GET SECOND BYTE
	MOV	L,A		;SAVE IN LOW BYTE OF RESULT
	
	RET
	
;********************************************************
; GETBYTE: GETS A BYTE FOR ACC FROM KEYBOARD, CY=0 IF FAILS
GETBYTE:
	PUSH	B		;SAVE B-C PAIR
	CALL	GETNIB		;GET FIRST NIBBLE
	JNC	RETGB		;IF BAD, DON'T WAIT FOR MORE
	RLC			;SHIFT INTO.
	RLC			;UPPER NIBBLE.
	RLC			;OF RESULT.
	RLC			;SO WE CAN INSERT LOWER NIBBLE
	MOV	B,A		;KEEP HIGH DIGIT IN B
	CALL	GETNIB		;GET SECOND DIGIT
	JNC	RETGB		;IF BAD, INDICATE SO
	ORA	B		;INSERT HIGH DIGIT
	STC			;INDICATE SUCESS
RETGB:	POP	B		;RESTORE B-C PAIR
	RET
	
;********************************************************
; GETNIB: GETS A NIBBLE FROM THE KEYBOARD (IN ASCII HEX)
GETNIB:	CALL	GETCHAR		;GET A CHARACTER
	CPI	#' 		;TEST FOR BLANK (ABORT1)
	RZ			;IF SO, RETURN INDICATING BAD (CY=0)
	CPI	0x0D		;TEST FOR <CR> (ABORT2)
	RZ			;IF SO, RETURN INDICATING BAD
	CPI	#'0		;TEST FOR INVALID (BELOW '0')
	JC	GETNIB		;IF SO, WAIT FOR MORE
	CPI	#'G		;TEST FOR INVALID (GREATER THAN 'F')
	JNC	GETNIB		;IF SO, IGNORE
	CALL	LCDPUTC		;DISPLAY CHARACTER
	CPI	0x3A		;TEST FOR INVALID
	JC	NUMH		;IF OK, WE ARE IN
	CPI	#'A		;TEST FOR INVALID
	JC	GETNIB		;IF BAD, IGNORE
	SUI	7		;CONVERT TO DIGIT
NUMH:	SUI	0x30		;CONVERT TO BINARY
	STC			;INDICATE SUCESS
	RET

;********************************************************
; WAITFORKEY: WAIT UNTIL USER PRESSES ANY KEY
WAITFORKEY:
	CALL 	GETCHAR		;GET A KEY

	ORA	A
	JZ	WAITFORKEY	;LOOP WHILE NO KEY PRESS
	
	RET	

;********************************************************
; GETCHAR
GETCHAR:
	PUSH	H		;SAVE H&L
	PUSH	B		;SAVE B&C
	
	CALL 	KBREAD		;READ ONCE
	MOV	B,A		;MOVE IN B

	CALL	SDELAY		;WAIT 
	
	CALL	KBREAD		;READ ONE MORE TIME
	
	CMP	B		;COMPARE RESULTS
	JZ	GETCHAR0
	
	MVI	A,0		;RETURN 0
	JMP	GETCHAR2
	
GETCHAR0:
	LXI	H,KBDTMP
	MOV	A,M		;LOAD LAST CHAR STORED IN MEMORY
	
	CMP	B		;COMPARE WITH THIS ONE
	JZ	GETCHAR1
	
	MOV	A,B		;NEW CHAR IN A
	MOV	M,A		;NEW CHAR IN MEM
	
	JMP 	GETCHAR2
	
GETCHAR1:
	MVI	A,0	
	JMP	GETCHAR2
	
GETCHAR2:
	POP	B		;RESTORE B&C
	POP	H		;RESTORE H&L
	RET

;********************************************************
; KBREAD, CHECK IF CHAR IS AVAILABLE FROM KEYBOARD.
; RETURNS CHAR VALUE IN A OR 0 IF NO CHAR IS AVAILABLE
; ** NOT DEBOUNCED **
KBREAD:
	PUSH	H		;SAVE H&L
	PUSH	B		;SAVE B&C
	
	MVI	B,0
	IN	KBD	
	ORA	A
	JNZ	KBDECODE
	
	MVI	B,1	
	IN	KBD+1
	ORA	A
	JNZ	KBDECODE	

	MVI	B,2
	IN	KBD+2
	CALL 	KBISSPECIAL	;CHECK FOR CONTROL CHAR (CTRL)
	ORA	A
	JNZ	KBDECODE	

	MVI	B,3
	IN	KBD+3
	CALL 	KBISSPECIAL
	ORA	A
	JNZ	KBDECODE	

	MVI	B,4
	IN	KBD+4
	CALL	KBISSPECIAL	;CHECK FOR SHIFT CHAR (LSHIFT)
	ORA	A
	JNZ	KBDECODE

	MVI	B,5
	IN	KBD+5
	CALL	KBISSPECIAL	;CHECK FOR FUNCTION CHAR (FUNCT)
	ORA	A
	JNZ	KBDECODE	
	
	MVI	B,6	
	IN	KBD+6
	ORA	A
	JNZ	KBDECODE	

	MVI	B,7
	IN	KBD+7
	CALL	KBISSPECIAL	;CHECK FOR FUNCTION CHAR (RSHIFT)
	ORA	A
	JNZ	KBDECODE	
	
; No char detected, return 0
	MVI	A,0	

	JMP	KBDEC5
	
; Char found, decode it
KBDECODE:
	MVI	C,0
	
KBDEC1:
	RAL			;ROTATE LEFT THROUGH CARRY
	JC 	KBDEC2		;SET BIT WAS FOUND
	INR	C		;INCREMENT POSITION COUNTER	
	JMP	KBDEC1
	
KBDEC2:
	MOV	A,B		;PORT NUMBER IN BITS 3-4-5
	RLC			;SHIFT 3 BITS TO THE LEFT
	RLC
	RLC
	ANI	0x38
	ORA	C		;C IN LOW BITS (0-1-2), A NOW CONTAINS DECODED CHAR (6 bits)
	
	MVI	B,0		;PUT 0,A in B,C
	MOV	C,A

; Must now translate to ASCII

	LXI	H,KBDFLG
	MOV	A,M			;LOAD KEYBOARD FLAGS
	ANI	KBLSHIFT+KBRSHIFT	;SHIFT (L OR R)?
	JNZ	KBDEC3
	
	LXI	H,KB2ASCL		;LOAD LOW CHAR TABLE
	JMP	KBDEC4
KBDEC3:
	LXI	H,KB2ASCH		;LOAD HI CHAR TABLE
KBDEC4:
	DAD	B
	MOV	A,M

KBDEC5:
	POP	B			;RESTORE B&C
	POP	H
	RET

;*******************
KBISSPECIAL:
	PUSH	PSW
	PUSH 	B
	PUSH 	H

	LXI	H,KBDFLG
	
	ANI	1		;CLEAR ALL BUT LSB
	MOV	C,A		;PUT RESULT IN C

; IDENTIFY FLAG AND SET/RESET IN KBDFLG
	MOV	A,B		;PORT# IN A
	
	MVI	B,0

	CPI	2
	JNZ	KBNOCTRL
; CTRL
	MVI	B,KBCTRL
	
KBNOCTRL:
	CPI	4
	JNZ	KBNOLSHIFT
; LEFT SHIFT	
	MVI	B,KBLSHIFT
	
KBNOLSHIFT:
	CPI	5
	JNZ	KBNOFUNCT
; FUNC	
	MVI	B,KBFUNC
	
KBNOFUNCT:
	CPI	7
	JNZ	KBNORSHIFT
; RIGHT SHIFT
	MVI	B,KBRSHIFT
	
KBNORSHIFT:

; SET OR RESET?
	MOV	A,C	
	ORA	A			;CHECK LSB
	JZ	KBRESET

; MUST SET FLAG
	MOV	A,M			;LOAD FLAG IN A
	ORA	B			;SET FLAG
	MOV	M,A

	JMP	KBISSPECIAL2
	
KBRESET:
; MUST RESET FLAG
	MOV	A,B			;PUT FLAG VALUE IN A
	CMA				;INVERT BITS
	MOV	B,A			;PUT BACK IN B
	
	MOV	A,M			;LOAD FLAG IN A
	ANA	B			;RESET FLAG
	
KBISSPECIAL2:
	MOV	M,A			;PUT BACK IN MEM
	
	POP	H
	POP	B
	POP	PSW
	
	ANI	254			;CLEAR LSB	
	RET

;********************************************************
; LCD ROUTINES
;********************************************************

;********************************************************
; CLEAR SCREEN
LCDCLS:
	PUSH	PSW

	CALL	LCDWAIT
	
	MVI	A,1		;OUT DATA
	OUT	LCDC

	CALL	SDELAY
	CALL	SDELAY

	POP	PSW	
	RET

;********************************************************
; CURSOR ON
LCDCURON:
	PUSH	PSW

	CALL	LCDWAIT
	
	MVI	A,15		;OUT DATA
	OUT	LCDC
	
	POP	PSW	
	RET

;********************************************************
; CURSOR OFF
LCDCUROFF:
	PUSH	PSW

	CALL	LCDWAIT
	
	MVI	A,12		;OUT DATA
	OUT	LCDC
	
	POP	PSW	
	RET

;********************************************************
; GOTO XY
; X IN H (0..19), Y IN L (0..3)
LCDGOTOXY:
	PUSH	PSW
	PUSH	H
	PUSH	B

	MOV	C,L		;LINE IN C
	MOV	A,H		;COL IN A

	LXI	H,GOTOXYOFS	;OFFSET TABLE
	MVI	B,0
	
	DAD	B		;INDEX IN TABLE
	
	MOV	B,M		;ADDR IN B
	
	ADD	B		;ADD TO X, COMPLETE ADDRESS IN NOW IN A
	
	ORI	0x80		;SET BIT 7

	CALL	LCDWAIT

	OUT	LCDC		
	
	POP	B
	POP	H
	POP	PSW
	
	RET

GOTOXYOFS:
	.db	0x00,0x40,0x14,0x54

;********************************************************
; PUT STRING
; NULL-TERMINATED STRING IN H,L
LCDPUTS:
	PUSH	PSW
	PUSH	H
	
LCDPUTS1:
	MOV	A,M		;LOAD CHAR FROM MEMORY
	ORA	A		;END OF STRING?
	JZ	LCDPUTS2

	CALL 	LCDPUTC		;PRINT CHAR
	
	INX	H		;INCREMENT ADDRESS	
	
	JMP	LCDPUTS1	;LOOP
	
LCDPUTS2:
	POP	H
	POP	PSW
	RET
	

;********************************************************
; PUT CHAR
; CHAR IN A
LCDPUTC:
	PUSH	PSW

	CALL	LCDWAIT
	
	OUT	LCDD		;PUT A ON DATA PORT
	
	POP	PSW
	RET	

;********************************************************
; PUT CHAR (BINARY)
LCDPUTCB:
	PUSH	PSW
	PUSH	B
	
	MOV	C,A		;KEEP IN NUMBER IN C
	
	MVI	B,8		;8 BINARY DIGITS
LCDPUTB0:
	MOV	A,C		;GET NUMBER
	RAL			;SHIFT LEFT
	MOV	C,A		;PUT BACK IN C
	JC	LCDPUTB1	;0 OR 1?
	
	MVI	A,#'0		;WE HAVE A ZERO
	JMP 	LCDPUTB2	
LCDPUTB1:
	MVI	A,#'1		;WE HAVE A ONE
	
LCDPUTB2:
	CALL	LCDPUTC		;PRINT THE BIT

	DCR	B		;LOOP FOR 8 BITS
	JNZ	LCDPUTB0
	
	POP	B
	POP	PSW
	RET

;********************************************************
; PUTHL (HEX) SHOW 16 BIT VALUE OF HL IN HEX
LCDPUTHL:
	PUSH 	PSW
	MOV	A,H		;GET H
	CALL	LCDPUTCH	;DISPLAY H IN HEX
	MOV	A,L		;GET L
	CALL	LCDPUTCH	;DISPLAY L IN HEX
	POP	PSW
	RET
	
;*********************************************************	
;* DISPLAYS 8 BIT VALUE OF A IN HEX
LCDPUTCH:
	PUSH	PSW		;SAVE LOW DIGIT
	RRC			;MAKE HIGH.
	RRC			;DIGIT.
	RRC			;INTO.
	RRC			;LOW DIGIT.
	CALL	LCDPUTN		;PRINT HIGH DIGIT
	POP	PSW		;GET LOW DIGIT BACK
	CALL	LCDPUTN		;PRINT LOW DIGIT
	RET
	
;********************************************************	
; LCDPUTN DISPLAYS NIBBLE IN LOWER 4 BITS OF A ('0'..'F')
LCDPUTN:
	PUSH	PSW
	ANI	0x0F		;GET RID OF EXCESS BAGGAGE
	ADI	0x30		;CONVERT TO ASCII NUMBER
	CPI	0x3A		;TEST FOR ALPHA CHARACTER
	JC	LCDPUTN2	;IF NOT, WE ARE OK
	ADI	7		;CONVERT TO CHARACTER
LCDPUTN2:	
	CALL	LCDPUTC
	POP	PSW
	RET

;********************************************************
; INITIALIZE LCD MODULE
INITLCD:
	PUSH	PSW
	
	CALL	SDELAY
	CALL	SDELAY
	CALL	SDELAY
	CALL	SDELAY
	CALL	SDELAY
	CALL	SDELAY
	CALL	SDELAY
	CALL	SDELAY
	CALL	SDELAY
	CALL	SDELAY
	
	MVI	A,0x30
	OUT	LCDC

	CALL	SDELAY
	CALL	SDELAY
		
	OUT	LCDC
		
	CALL 	SDELAY	
	
	OUT	LCDC
	
	CALL 	SDELAY	

; Function set
	MVI	A,0x38		
	OUT	LCDC
	
	CALL 	SDELAY	

; Display OFF
	MVI	A,0x08		
	OUT	LCDC
	
	CALL 	SDELAY	

; Display ON	
	MVI	A,0x01		
	OUT	LCDC
	
	CALL 	SDELAY	
	
	MVI	A,0x0C
	OUT	LCDC
	
	CALL	SDELAY

	MVI	A,0x06
	OUT	LCDC

	CALL	SDELAY
	CALL	SDELAY

	POP	PSW
	RET

;********************************************************
; CHECKS LCD BUSY FLAG - RETURNS WHEN 0
LCDWAIT:
	PUSH 	PSW
LCDW1:
	IN	LCDC
	RAL			;ROTATE LEFT THROUGH CARRY
	JNC	LCDW2
	JMP	LCDW1
	
LCDW2:	POP	PSW
	RET

;********************************************************
; General purpose functions
;********************************************************

;********************************************************
; SDELAY, WAITS A FINITE TIME INTERVAL (approx 2ms)
SDELAY:	PUSH	PSW
	PUSH	H		;SAVE H-L
	LXI	H,0x004C	;START COUNTING
DEL1:	DCX	H		;REDUCE COUNT
	MOV	A,H		;GET HIGH VALUE
	ORA	L		;TEST FOR ZERO WITH LOW VALUE
	JNZ	DEL1		;IF NOT, KEEP COUNTING
	POP	H		;RESTORE H-L
	POP	PSW
	RET


KB2ASCL:
	.db	'7,'n,'5,'v,'3,'x,'1,0
	.db	'j,'t,'r,'f,'d,'q,27,0
	.db	'm,'6,'b,'4,'c,'2,'z,0
	.db	'k,'9,';,'),'%,'<,0,0
	.db	' ,',,':,4,5,6,7,1
	.db	'u,'i,'o,'p,'{,'$,8,0
	.db	'y,'h,'g,'e,'w,'s,'a,0
	.db	'8,'l,'0,'=,'-,0,13,1

KB2ASCH:
	.db	'\\,'N,'(,'V,'",'X,'&,0
	.db	'J,'T,'R,'F,'D,'Q,'~,0
	.db	'M,'`,'B,39,'C,'/,'Z,0
	.db	'K,'[,'.,'?,'|,'>,0,0
	.db	' ,'?,'@,4,5,6,7,1
	.db	'U,'I,'O,'P,'},'*,'#,0
	.db	'Y,'H,'G,'E,'W,'S,'A,0
	.db	'!,'L,'],'+,'^,0,13,1
	
GOTOSTR:	.asciz	'Goto: '
EXECSTR:	.asciz	'Exec: '

INSTR:		.asciz	'Input - Port: '
INSTR2:		.asciz	'       Value: '

OUTSTR:		.asciz	'Output - Port: '
OUTSTR2:	.asciz	'        Value: '

BEEPSTR:	.asciz	'Beep - Note: '

DELAYSTR:	.asciz	'Delay - 100mS X: '

RIMSTR:		.asciz	'RIM: '
SIMSTR:		.asciz	'SIM: '

VERSIONSTR:	.asciz 'Monitor V0.0.1'

INTSTR:		.asciz	'Interrupt!'


;*********************************************************
;* RAM VARIABLES
;*********************************************************

.area	DATA	(REL,CON)

KBDTMP:		.ds	1
KBDFLG:		.ds	1

BASE:		.ds	2

INOUTF:		.ds	3
